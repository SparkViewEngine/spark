<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Castle.ActiveRecord</name>
    </assembly>
    <members>
        <member name="T:Castle.ActiveRecord.ValidateIsUniqueAttribute">
            <summary>
            Validate that the property's value is unique in the database when saved
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ValidateIsUniqueAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidateIsUniqueAttribute"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ValidateIsUniqueAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ValidateIsUniqueAttribute"/> class.
            </summary>
            <param name="errorMessage">The error message.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ValidateIsUniqueAttribute.Build">
            <summary>
            Constructs and configures an <see cref="T:Castle.Components.Validator.IValidator"/>
            instance based on the properties set on the attribute instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordAttribute">
            <summary>
            Associate meta information related to the
            desired table mapping.
            </summary>
            <example>
            <code>
            [ActiveRecord("tb_Order")]
            public class Order : ActiveRecordBase
            {
            }
            </code>
            </example>
            <remarks>
            If no table is specified, the class name 
            is used as table name
            </remarks>
        </member>
        <member name="T:Castle.ActiveRecord.BaseAttribute">
            <summary>
            Implement common properties shared by some
            attributes
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.WithAccessAttribute">
            <summary>
            Base class that allows specifying an access strategy to get/set the value for an object' property.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.WithAccessAttribute.Access">
            <summary>
            Gets or sets the access strategy for this property
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.WithAccessAttribute.CustomAccess">
            <summary>
            Gets or sets the custom access strategy
            </summary>
            <value>The custom access.</value>
        </member>
        <member name="P:Castle.ActiveRecord.WithAccessAttribute.AccessString">
            <summary>
            Gets the access strategy string for NHibernate's mapping.
            </summary>
            <value>The access string.</value>
        </member>
        <member name="P:Castle.ActiveRecord.BaseAttribute.Cache">
            <summary>
            Gets or sets the cache strategy to use for this property
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BaseAttribute.CacheRegion">
            <summary>
            Gets or sets the a name for a cache region.
            </summary>
            <value>The cache region name.</value>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordAttribute.#ctor">
            <summary>
            Uses the class name as table name
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordAttribute.#ctor(System.String)">
            <summary>
            Associates the specified table with the target type
            </summary>
            <param name="table"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordAttribute.#ctor(System.String,System.String)">
            <summary>
            Associates the specified table and schema with the target type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Table">
            <summary>
            Gets or sets the table name associated with the type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Schema">
            <summary>
            Gets or sets the schema name associated with the type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Proxy">
            <summary>
            Associates a proxy type with the target type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DiscriminatorColumn">
            <summary>
            Gets or sets the Discriminator column for
            a table inheritance modeling
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DiscriminatorType">
            <summary>
            Gets or sets the column type (like string or integer)
            for the discriminator column
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DiscriminatorValue">
            <summary>
            Gets or sets the value that represents the
            target class on the discriminator column
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DiscriminatorLength">
            <summary>
            Gets or sets the length of the discriminator
            column (valid for string type only)
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Where">
            <summary>
            SQL condition to retrieve objects
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Lazy">
            <summary>
            Enable lazy loading for the type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.LazySpecified">
            <summary>
            Gets a value indicating whether explicit lazy behavior was specified.
            If explicit lazy behavior was not specified, it goes to the configuration to decide if the type should
            be lazy or not.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DynamicUpdate">
            <summary>
            From NHibernate documentation:
            Specifies that UPDATE SQL should be 
            generated at runtime and contain only 
            those columns whose values have changed.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.DynamicInsert">
            <summary>
            From NHibernate documentation:
            Specifies that INSERT SQL should be 
            generated at runtime and contain only 
            the columns whose values are not null.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Persister">
            <summary>
            From NHibernate documentation:
            Specifies a custom <see cref="T:NHibernate.Persister.Entity.IEntityPersister"/>.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.SelectBeforeUpdate">
            <summary>
            From NHibernate documentation:
            Specifies that NHibernate should never perform an SQL UPDATE 
            unless it is certain that an object is actually modified. In 
            certain cases (actually, only when a transient object has 
            been associated with a new session using update()), this means 
            that NHibernate will perform an extra SQL SELECT to determine 
            if an UPDATE is actually required.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Polymorphism">
            <summary>
            From NHibernate documentation:
            Determines whether implicit or explicit query polymorphism is used.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Mutable">
            <summary>
            From NHibernate documentation:
            Specifies that instances of the class are (not) mutable.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.BatchSize">
            <summary>
            From NHibernate documentation:
            Specify a "batch size" for fetching instances of 
            this class by identifier.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Locking">
            <summary>
            From NHibernate documentation:
            Determines the optimistic locking strategy.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.UseAutoImport">
            <summary>
            From NHibernate documentation:
            The auto-import attribute lets us use 
            unqualified class names in the query language, 
            by default. The assembly  and namespace attributes 
            specify the assembly where persistent classes 
            are located and the namespace they are declared in.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.Tuplizer">
            <summary>
            From NHibernate documentation:
            A tuplizer defines the contract for things which know how to manage
            a particular representation of a piece of data, given that
            representation's <see cref="T:NHibernate.EntityMode"/> (the entity-mode
            essentially defining which representation).
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordAttribute.SchemaAction">
            <summary>
            Determines the action of CreateSchema, DropSchema or UpdateSchema for this table.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordSkipAttribute">
            <summary>
            Denotes that the specific class - 
            which is an <see cref="T:Castle.ActiveRecord.ActiveRecordBase"/> subclass
            should not be processed by the framework
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Attributes.AddEventListenerAttribute">
            <summary>
            Instructs <see cref="T:Castle.ActiveRecord.ActiveRecordStarter"/> to add the specified type
            or assembly to the event listeners
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Attributes.EventListenerAssemblyAttribute">
            <summary>
            Base class for <see cref="T:Castle.ActiveRecord.Attributes.AddEventListenerAttribute"/> and <see cref="T:Castle.ActiveRecord.Attributes.IgnoreEventListenerAttribute"/>
            to hold common attributes and helpers.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Attributes.EventListenerAssemblyAttribute.ParseStringExpression(System.String)">
            <summary>
            Parses the constructor argument and sets the specified object
            </summary>
            <param name="expression">the constructor arg</param>
        </member>
        <member name="P:Castle.ActiveRecord.Attributes.EventListenerAssemblyAttribute.Assembly">
            <summary>
            The assembly to scan for event listeners or to ignore listeners from.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Attributes.EventListenerAssemblyAttribute.Type">
            <summary>
            The event listener type to add or ignore
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Attributes.AddEventListenerAttribute.#ctor(System.String)">
            <summary>
            Adds an assembly to the event listener list. All types that implement
            at least one IXxxEventListener interface (<see cref="N:NHibernate.Event"/>)
            are used as event listeners.
            </summary>
            <param name="assemblyName">The name of the assembly. A partial name is sufficient.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Attributes.AddEventListenerAttribute.#ctor(System.Type)">
            <summary>
            Adds the specified type as an event listener.
            </summary>
            <param name="type">A type that implements at least one event listener inzterface.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Attributes.AddEventListenerAttribute.Exclude">
            <summary>
            Holds connections to exclude the listener from
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Attributes.AddEventListenerAttribute.Include">
            <summary>
            Holds connections that the listener will be exclusively added to.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Attributes.AddEventListenerAttribute.ExcludeEvent">
            <summary>
            Holds events to exclude the listener from
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Attributes.AddEventListenerAttribute.IncludeEvent">
            <summary>
            Holds events that the listener will be exclusively added to.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Attributes.AddEventListenerAttribute.Singleton">
            <summary>
            Specifies that all events for all configurations should be served by a single instance
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Attributes.AddEventListenerAttribute.ReplaceExisting">
            <summary>
            If <c>true</c>, any existing listeners for that Event will be replaced.
            Otherwise the listener will be added without removing the existing listeners.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.AnyAttribute">
            <summary>
            This attribute is used to create &lt;any/&gt; assoication, a polymorphic assoication to classes that
            do not share a common base class.
            <example>
            Assuming we have two classes that implement IPayment, CreditCard and BankAccount, and we want a property
            that can point ot either one of them. We can map it like this:
            <code>
            [Any(typeof (long), MetaType=typeof (string),
            	TypeColumn="BILLING_DETAILS_TYPE",
            	IdColumn="BILLING_DETAILS_ID",
            	Cascade=CascadeEnum.SaveUpdate)]
            [Any.MetaValue("CREDIT_CARD", typeof (CreditCard))]
            [Any.MetaValue("BANK_ACCOUNT", typeof (BankAccount))]
            public IPayment Payment { get { ... } set { ... } }
            </code>
             The [Any] attribute specify that the id type is long, that the meta type (the type that specify the type of 
             the class) is string.
             The TypeColumn = "BILLING_DETAILS_TYPE" means that Active Record will look in this column to figure out what the type
             of the associated entity is.
             The IdColumn = "BILLING_DETAILS_ID" means that Active Record will use this column in conjuction with the type of the entity
             to find the relevant entity. This is the id of the associated entity (which can point to either back account or credit card).
             Cascade has the usual semantics.
             
             [Any.MetaValue("CREDIT_CARD", typeof (CreditCard))] - means that when Active Record encounters a "CREDIT_CARD" value in 
             the "BILLING_DETAILS_TYPE", is assumes that the id in the "BILLING_DETAILS_ID" is the id of a CreditCard entity.
             
             [Any.MetaValue("BANK_ACCOUNT", typeof (BankAccount))] - same, just for "BANK_ACCOUNT" meaning that the id in "BILLING_DETAILS_ID"
             is an id of a bank account.
             </example>
            </summary>
            <remarks>
            This is supplied for advanced sceanrios.
            </remarks>
        </member>
        <member name="T:Castle.ActiveRecord.WithAccessOptionalTableAttribute">
            <summary>
            Base class that allows specifying an alternate table for an object's field or property.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.WithAccessOptionalTableAttribute.Table">
            <summary>
            Gets or sets the table name if joined
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.AnyAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.AnyAttribute"/> class.
            </summary>
            <remarks>Using this constructor defaults the idType to Int32</remarks>
        </member>
        <member name="M:Castle.ActiveRecord.AnyAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.AnyAttribute"/> class.
            </summary>
            <param name="idType">Type of the id.</param>
        </member>
        <member name="P:Castle.ActiveRecord.AnyAttribute.IdType">
            <summary>
            Gets or sets the type of the id.
            </summary>
            <value>The type of the id.</value>
        </member>
        <member name="P:Castle.ActiveRecord.AnyAttribute.MetaType">
            <summary>
            Gets or sets the type of the meta column
            </summary>
            <value>The type of the meta.</value>
        </member>
        <member name="P:Castle.ActiveRecord.AnyAttribute.Cascade">
            <summary>
            Gets or sets the cascade options
            </summary>
            <value>The cascade.</value>
        </member>
        <member name="P:Castle.ActiveRecord.AnyAttribute.TypeColumn">
            <summary>
            Gets or sets the type column name
            </summary>
            <value>The type column.</value>
        </member>
        <member name="P:Castle.ActiveRecord.AnyAttribute.IdColumn">
            <summary>
            Gets or sets the id column name
            </summary>
            <value>The id column.</value>
        </member>
        <member name="P:Castle.ActiveRecord.AnyAttribute.Index">
            <summary>
            Gets or sets the index column name
            </summary>
            <value>The index.</value>
        </member>
        <member name="P:Castle.ActiveRecord.AnyAttribute.Insert">
            <summary>
            Gets or sets a value indicating whether the column should be inserted when inserting.
            </summary>
            <value><c>true</c> if should insert; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Castle.ActiveRecord.AnyAttribute.Update">
            <summary>
            Gets or sets a value indicating whether the column should be is updated when updating.
            </summary>
            <value><c>true</c> if should update; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Castle.ActiveRecord.AnyAttribute.NotNull">
            <summary>
            Gets or sets a value indicating whether this property cannot be null.
            </summary>
            <value><c>true</c> if this property cannot be null; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Any">
            <summary>
            Avoids the AnyAttribute.MetaValue syntax
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Any.MetaValueAttribute">
            <summary>
            This is used to specify a meta value in an [Any] assoication
            Any.MetaValue is used to connect a value (such as "CREDIT_CARD") to its type ( typeof(CreditCard) ).
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Any.MetaValueAttribute.#ctor(System.String,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Any.MetaValueAttribute"/> class.
            </summary>
            <param name="value">The value.</param>
            <param name="clazz">The clazz.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Any.MetaValueAttribute.#ctor(System.Byte,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Any.MetaValueAttribute"/> class.
            Allows a byte to be used as a meta-value
            </summary>
            <param name="value">The value.</param>
            <param name="clazz">The clazz.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Any.MetaValueAttribute.#ctor(System.Int16,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Any.MetaValueAttribute"/> class.
            Allows a short to be used as a meta-value
            </summary>
            <param name="value">The value.</param>
            <param name="clazz">The clazz.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Any.MetaValueAttribute.#ctor(System.Int32,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Any.MetaValueAttribute"/> class.
            Allows a int to be used as a meta-value
            </summary>
            <param name="value">The value.</param>
            <param name="clazz">The clazz.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Any.MetaValueAttribute.System#IComparable#CompareTo(System.Object)">
            <summary>
            This is here so the XmlGenerationVisitor will always
            output the meta-values in consistent order, to aid the tests.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Any.MetaValueAttribute.Value">
            <summary>
            Gets or sets the value for this class
            </summary>
            <value>The value.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Any.MetaValueAttribute.Class">
            <summary>
            Gets or sets the class that match this value
            </summary>
            <value>The class.</value>
        </member>
        <member name="T:Castle.ActiveRecord.NotFoundBehaviour">
            <summary>
            Define how broken relations should be handled.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.NotFoundBehaviour.Default">
            <summary>
            Throw an exception when the relation is broken.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.NotFoundBehaviour.Exception">
            <summary>
            Throw an exception when the relation is broken.
            </summary>
            <remarks>this is the default behaviour</remarks>
        </member>
        <member name="F:Castle.ActiveRecord.NotFoundBehaviour.Ignore">
            <summary>
            Ignore the broken relation and update
            the FK to null on the next save.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.BelongsToAttribute">
            <summary>
            Maps a one to one association.
            </summary>
            <example>
            <code>
            public class Post : ActiveRecordBase
            {
            		...
            
            		[BelongsTo("blogid")]
            		public Blog Blog
            		{
            		get { return _blog; }
            		set { _blog = value; }
            		}
            	</code>
            </example>
            <remarks>
            Please note that the 'blogid' foreign key lies on the 'Post' table.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.BelongsToAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.BelongsToAttribute"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.BelongsToAttribute.#ctor(System.String)">
            <summary>
            Indicates the name of the column to be used on the association.
            Usually the name of the foreign key field on the underlying database.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Type">
            <summary>
            Defines the target type of the association. It's usually inferred from the property type.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Column">
            <summary>
            Defines the column used by association (usually a foreign key)
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.CompositeKeyColumns">
            <summary>
            Defines the Composite Key columns used by association (aka Natural Keys).
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Cascade">
            <summary>
            Defines the cascading behavior of this association.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.OuterJoin">
            <summary>
            Defines the outer join behavior of this association.
            NHibernate has deprecated the outer-join attribute so this property is
            marked obsolete - it now converts to and from the fetch value.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Fetch">
            <summary>
            Chooses between outer-join fetching
            or sequential select fetching.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Lazy">
            <summary>
            Chooses between proxy or eager fetching.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.PropertyRef">
            <summary>
            From NHibernate docs: The name of a property of the 
            associated class that is joined to the primary key 
            of this class. If not specified, the primary key of 
            the associated class is used.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Update">
            <summary>
            Set to <c>false</c> to ignore this association when updating entities of this ActiveRecord class.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Insert">
            <summary>
            Set to <c>false</c> to ignore this association when inserting entities of this ActiveRecord class.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.NotNull">
            <summary>
            Indicates whether this association allows nulls or not.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Unique">
            <summary>
            Indicates whether this association is unique.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.NotFoundBehaviour">
            <summary>
            Gets or sets the way broken relations are handled.
            </summary>
            <value>The behaviour.</value>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.UniqueKey">
            <summary>
            From NHibernate documentation:
            A unique-key attribute can be used to group columns 
            in a single unit key constraint. 
            </summary>
            <value>unique key name</value>
            <remarks>
            Currently, the 
            specified value of the unique-key attribute is not 
            used to name the constraint, only to group the columns 
            in the mapping file.
            </remarks>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.Index">
            <summary>
            From NHibernate documentation:
            specifies the name of a (multi-column) index
            </summary>
            <value>index name</value>
        </member>
        <member name="P:Castle.ActiveRecord.BelongsToAttribute.ForeignKey">
            <summary>
            Gets and sets the name of the foreign key constraint 
            generated for an association.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.CollectionIDType">
            <summary>
            Defines the values for the generator for the Collection Id values.w
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CollectionIDType.Identity">
            <summary>
            Use Identity column (auto number)
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CollectionIDType.Sequence">
            <summary>
            Use a sequence
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CollectionIDType.HiLo">
            <summary>
            Use the HiLo algorithm to get the next value
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CollectionIDType.SeqHiLo">
            <summary>
            Use a sequence and a HiLo algorithm - better performance on Oracle
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CollectionIDType.UuidHex">
            <summary>
            Use the hex representation of a unique identifier
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CollectionIDType.UuidString">
            <summary>
            Use the string representation of a unique identifier
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CollectionIDType.Guid">
            <summary>
            Generate a Guid for the primary key
            Note: You should prefer using GuidComb over this value.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CollectionIDType.GuidComb">
            <summary>
            Generate a Guid in sequence, so it will have better insert performance in the DB.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CollectionIDType.Assigned">
            <summary>
            The key value is always assigned.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CollectionIDType.Foreign">
            <summary>
            This is a foreign key to another table
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.CollectionIDAttribute">
            <summary>
            Used for a collection that requires a collection id.
            </summary>
            <example><code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[HasManyAndBelongs/HasMany]
            	[CollectionIDAttribute(CollectionIDAttribute.Native)]
            	public int Id
            	{
            		get { return _id; }
            		set { _id = value; }
            	}
            </code></example>
        </member>
        <member name="M:Castle.ActiveRecord.CollectionIDAttribute.#ctor(Castle.ActiveRecord.CollectionIDType,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.CollectionIDAttribute"/> class.
            </summary>
            <param name="generator">The generator.</param>
            <param name="column">The column.</param>
            <param name="ColumnType">Type of the column.</param>
        </member>
        <member name="P:Castle.ActiveRecord.CollectionIDAttribute.Generator">
            <summary>
            Gets or sets the generator.
            </summary>
            <value>The generator.</value>
        </member>
        <member name="P:Castle.ActiveRecord.CollectionIDAttribute.Column">
            <summary>
            Gets or sets the column name
            </summary>
            <value>The column.</value>
        </member>
        <member name="P:Castle.ActiveRecord.CollectionIDAttribute.ColumnType">
            <summary>
            Gets or sets the type of the column.
            </summary>
            <value>The type of the column.</value>
        </member>
        <member name="T:Castle.ActiveRecord.CompositeKeyAttribute">
            <summary>
            Defines that the target property is a composite key
            for the scope class
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.CompositeKeyAttribute.UnsavedValue">
            <summary>
            Gets or sets the unsaved value.
            </summary>
            <value>The unsaved value.</value>
        </member>
        <member name="T:Castle.ActiveRecord.CompositeUserTypeAttribute">
            <summary>
            Maps the property to db using a NHibernate's <see cref="T:NHibernate.UserTypes.ICompositeUserType"/>.
            </summary>
            <remarks>
            You should specify the column names and the ICompositeUserType implementor.
            </remarks>
            <example>
            <code>
            	[CompositeUserType(typeof(DoubleStringType), new string[] {"Product_FirstName", "Product_LastName"})]
            	public string[] Name
            	{
            		get { return name; }
            		set { name = value; }
            	}
            </code>
            or 
            <code>
            	[CompositeUserType(
            		typeof(DoubleStringType), 
            		new string[]{"Manufacturer_FirstName", "Manufacturer_LastName"}, 
            		Length = new int[] {4, 5} )]
            	public string[] ManufacturerName
            	{
            		get { return manufacturerName; }
            		set { manufacturerName = value; }
            	}
            </code>
            </example>
        </member>
        <member name="M:Castle.ActiveRecord.CompositeUserTypeAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.CompositeUserTypeAttribute"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.CompositeUserTypeAttribute.#ctor(System.Type,System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.CompositeUserTypeAttribute"/> class.
            </summary>
            <param name="compositeType">Type of the ICompositeUserType implmentor.</param>
            <param name="columnNames">The column names.</param>
        </member>
        <member name="M:Castle.ActiveRecord.CompositeUserTypeAttribute.#ctor(System.String,System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.CompositeUserTypeAttribute"/> class.
            </summary>
            <param name="compositeTypeName">Type name of the ICompositeUserType implmentor.</param>
            <param name="columnNames">The column names.</param>
        </member>
        <member name="P:Castle.ActiveRecord.CompositeUserTypeAttribute.CompositeType">
            <summary>
            Gets or sets the type of the ICompositeUserType implementor.
            </summary>
            <value>The type of the composite.</value>
        </member>
        <member name="P:Castle.ActiveRecord.CompositeUserTypeAttribute.ColumnNames">
            <summary>
            Gets or sets the column names.
            </summary>
            <value>The column names.</value>
        </member>
        <member name="P:Castle.ActiveRecord.CompositeUserTypeAttribute.Length">
            <summary>
            Gets or sets the length of the columns.
            </summary>
            <value>The columns length.</value>
        </member>
        <member name="P:Castle.ActiveRecord.CompositeUserTypeAttribute.Update">
            <summary>
            Set to <c>false</c> to ignore this property when updating entities of this ActiveRecord class.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.CompositeUserTypeAttribute.Insert">
            <summary>
            Set to <c>false</c> to ignore this property when inserting entities of this ActiveRecord class.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.OptimisticLocking">
            <summary>
            Defines the values for optimistic locking
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.OptimisticLocking.None">
            <summary>
            do not use optimistic locking
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.OptimisticLocking.Version">
            <summary>
            check the version/timestamp columns
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.OptimisticLocking.Dirty">
            <summary>
            check the changed columns
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.OptimisticLocking.All">
            <summary>
            check all columns
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Polymorphism">
            <summary>
            Define the polymorphism options
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Polymorphism.Implicit">
            <summary>
            Implicit polymorphism
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Polymorphism.Explicit">
            <summary>
            Explicit polymorphism
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.CacheEnum">
            <summary>
            Define the caching options
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CacheEnum.Undefined">
            <summary>
            Default value, no caching
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CacheEnum.ReadOnly">
            <summary>
            Read only cache - use for cases where no write are performed.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CacheEnum.ReadWrite">
            <summary>
            Read write cache
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CacheEnum.NonStrictReadWrite">
            <summary>
            Read write cache with looser semantics.
            Check NHibernate's documentation for the detials.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.OuterJoinEnum">
            <summary>
            Define outer join options
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.OuterJoinEnum.Auto">
            <summary>
            Let NHibernate decide what to do
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.OuterJoinEnum.True">
            <summary>
            Use outer join
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.OuterJoinEnum.False">
            <summary>
            Do not use outer join
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.FetchEnum">
            <summary>
            Define the possible fetch option values
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.FetchEnum.Unspecified">
            <summary>
            Let NHibernate decide what to do here
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.FetchEnum.Join">
            <summary>
            Use a JOIN to load the data
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.FetchEnum.Select">
            <summary>
            Use a seperate SELECT statement to load the data
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.FetchEnum.SubSelect">
            <summary>
            Use a seperate SELECT statement to load the data, re-running the original query in a subselect
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.FetchWhen">
            <summary>
            Defines the possible lazy option values.
            See http://nhforge.org/doc/nh/en/index.html#performance-fetching
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.FetchWhen.OnInvoke">
            <summary>
            Specifies that the property should be fetched lazily when the instance variable is first accessed.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.FetchWhen.Immediate">
            <summary>
            Specifies that the association will always be eagerly fetched.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.CascadeEnum">
            <summary>
            Defines the cascading behaviour of this association.
            </summary>
            <remarks>
            Entities has associations to other objects, this may be an association to a single item (<see cref="T:Castle.ActiveRecord.BelongsToAttribute"/>)
            or an association to a collection (<see cref="T:Castle.ActiveRecord.HasManyAttribute"/>, <see cref="T:Castle.ActiveRecord.HasManyToAnyAttribute"/>).
            At any rate, you are able to tell NHibernate to automatically traverse an entity's associations, and act according 
            to the cascade option. For instance, adding an unsaved entity to a collection with <see cref="F:Castle.ActiveRecord.CascadeEnum.SaveUpdate"/>
            cascade will cause it to be saved along with its parent object, without any need for explicit instructions on our side.
            </remarks>
        </member>
        <member name="F:Castle.ActiveRecord.CascadeEnum.None">
            <summary>
            No cascading. This is the default.
            The cascade should be handled manually.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CascadeEnum.All">
            <summary>
            Cascade save, update and delete.
            When the object is saved, updated or deleted, the associations will be checked
            and the objects found will also be saved, updated or deleted.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CascadeEnum.SaveUpdate">
            <summary>
            Cascade save and update.
            When the object is saved or updated, the associations will be checked and any object that requires
            will be saved or updated (including saving or updating the associations in many-to-many scenario).
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.CascadeEnum.Delete">
            <summary>
            Cascade delete.
            When the object is deleted, all the objects in the association will be deleted as well.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ManyRelationCascadeEnum">
            <summary>
            Defines the cascading behaviour of this association.
            </summary>
            <remarks>
            Entities has associations to other objects, this may be an association to a single item (<see cref="T:Castle.ActiveRecord.BelongsToAttribute"/>)
            or an association to a collection (<see cref="T:Castle.ActiveRecord.HasManyAttribute"/>, <see cref="T:Castle.ActiveRecord.HasManyToAnyAttribute"/>).
            At any rate, you are able to tell NHibernate to automatically traverse an entity's associations, and act according 
            to the cascade option. For instance, adding an unsaved entity to a collection with <see cref="F:Castle.ActiveRecord.CascadeEnum.SaveUpdate"/>
            cascade will cause it to be saved along with its parent object, without any need for explicit instructions on our side.
            </remarks>
        </member>
        <member name="F:Castle.ActiveRecord.ManyRelationCascadeEnum.None">
            <summary>
            No cascading. This is the default.
            The cascade should be handled manually.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.ManyRelationCascadeEnum.All">
            <summary>
            Cascade save, update and delete.
            When the object is saved, updated or deleted, the associations will be checked
            and the objects found will also be saved, updated or deleted.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.ManyRelationCascadeEnum.SaveUpdate">
            <summary>
            Cascade save and update.
            When the object is saved or updated, the associations will be checked and any object that requires
            will be saved or updated (including saving or updating the associations in many-to-many scenario).
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.ManyRelationCascadeEnum.Delete">
            <summary>
            Cascade delete.
            When the object is deleted, all the objects in the association will be deleted as well.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.ManyRelationCascadeEnum.AllDeleteOrphan">
            <summary>
            Cascade save, update and delete, removing orphan children.
            When an object is saved, updated or deleted, the associations will be checked and all objects found
            will be saved, updated or deleted as well.
            In additional to that, when an object is removed from the association and not associated with another object (orphaned), it will also be deleted.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.EventListenerAttribute">
            <summary>
            Marks an NHibernate 2.0 event listener. The decorated class must implement
            at least one of the I...EventListener-interfaces at NHibernate.Event
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.EventListenerAttribute.ReplaceExisting">
            <summary>
            If <c>true</c>, any existing listeners for that Event will be replaced.
            Otherwise the listener will be added without removing the existing listeners.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.EventListenerAttribute.Ignore">
            <summary>
            If <c>true</c>, the listener won't be registered at all.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.EventListenerAttribute.SkipEvent">
            <summary>
            Defines that a single event should be skipped although it is defined in the
            listener
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.EventListenerAttribute.Singleton">
            <summary>
            Specifies that all events for all configurations should be served by a single instance
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.EventListenerAttribute.Include">
            <summary>
            Defines the base types for which the listener will be added.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.EventListenerAttribute.Exclude">
            <summary>
            Defines the base types for which the listener will not be added.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.FieldAttribute">
            <summary>
            Maps a standard column of the table.
            </summary>
            <example>
            In the following example, the column is also
            called 'name', so you don't have to specify.
            <code>
            public class Blog : ActiveRecordBase
            {
            	[Field]
            	string name;
            	
            	
            </code>
            </example>
        </member>
        <member name="M:Castle.ActiveRecord.FieldAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.FieldAttribute"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.FieldAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.FieldAttribute"/> class.
            </summary>
            <param name="column">The column name.</param>
        </member>
        <member name="M:Castle.ActiveRecord.FieldAttribute.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.FieldAttribute"/> class.
            </summary>
            <param name="column">The column name</param>
            <param name="type">The column type.</param>
        </member>
        <member name="P:Castle.ActiveRecord.FieldAttribute.NotNull">
            <summary>
            Gets or sets a value indicating whether the column allows null values
            </summary>
            <value><c>true</c> if [not null]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Castle.ActiveRecord.FieldAttribute.Length">
            <summary>
            Gets or sets the length of this column. char(10), etc
            </summary>
            <value>The length.</value>
        </member>
        <member name="P:Castle.ActiveRecord.FieldAttribute.Column">
            <summary>
            Gets or sets the column name
            </summary>
            <value>The column.</value>
        </member>
        <member name="P:Castle.ActiveRecord.FieldAttribute.UniqueKey">
            <summary>
            From NHibernate documentation:
            A unique-key attribute can be used to group columns 
            in a single unit key constraint. 
            </summary>
            <value>unique key name</value>
            <remarks>
            Currently, the 
            specified value of the unique-key attribute is not 
            used to name the constraint, only to group the columns 
            in the mapping file.
            </remarks>
        </member>
        <member name="P:Castle.ActiveRecord.FieldAttribute.Index">
            <summary>
            From NHibernate documentation:
            specifies the name of a (multi-column) index
            </summary>
            <value>index name</value>
        </member>
        <member name="P:Castle.ActiveRecord.FieldAttribute.SqlType">
            <summary>
            From NHibernate documentation:
            overrides the default column type
            </summary>
            <value>column_type</value>
        </member>
        <member name="P:Castle.ActiveRecord.FieldAttribute.Check">
            <summary>
            From NHibernate documentation:
            create an SQL check constraint on either column or table
            </summary>
            <value>Sql Expression</value>
        </member>
        <member name="P:Castle.ActiveRecord.FieldAttribute.Update">
            <summary>
            Set to <c>false</c> to ignore this 
            field when updating entities of this ActiveRecord class.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.FieldAttribute.Insert">
            <summary>
            Set to <c>false</c> to ignore this 
            field when inserting entities of this ActiveRecord class.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.FieldAttribute.Unique">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Castle.ActiveRecord.FieldAttribute"/> is unique.
            </summary>
            <value><c>true</c> if unique; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Castle.ActiveRecord.FieldAttribute.Formula">
            <summary>
            Gets or sets the formula used to calculate this field
            </summary>
            <value>The formula.</value>
        </member>
        <member name="P:Castle.ActiveRecord.FieldAttribute.ColumnType">
            <summary>
            Gets or sets the type of the column.
            </summary>
            <value>The type of the column.</value>
        </member>
        <member name="P:Castle.ActiveRecord.FieldAttribute.Default">
            <summary>
            Gets or sets the default value for a column (used by schema generation). 
            Please note that you should be careful to set Insert=false or set the value to the same 
            as the default on the database. 
            </summary>
            <value>The default value for the column.</value>
        </member>
        <member name="T:Castle.ActiveRecord.HasAndBelongsToManyAttribute">
            <summary>
            Maps a many to many association with an association table.
            </summary>
            <example><code>
            public class Company : ActiveRecordBase
            {
              ...
              
              [HasAndBelongsToMany( typeof(Person), RelationType.Bag, Table="PeopleCompanies", ColumnRef="person_id", ColumnKey="company_id" )]
              public IList People
              {
              	get { return _people; }
              	set { _people = value; }
              }
            }
            </code></example>
            <remarks>The <see cref="P:Castle.ActiveRecord.HasAndBelongsToManyAttribute.ColumnKey"/> must specify the key on the 
            association table that points to the primary key of this class. In 
            the example, 'company_id' points to 'Company'.
            </remarks>
        </member>
        <member name="T:Castle.ActiveRecord.RelationAttribute">
            <summary>
            Base class to define common relation information
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.RelationType">
            <summary>
            Gets or sets the type of the relation.
            </summary>
            <value>The type of the relation.</value>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.MapType">
            <summary>
            Gets or sets the type of the map.
            </summary>
            <value>The type of the map.</value>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.Table">
            <summary>
            Gets or sets the table for this relation
            </summary>
            <value>The table.</value>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.Schema">
            <summary>
            Gets or sets the schema for this relation (dbo., etc)
            </summary>
            <value>The schema name.</value>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.Lazy">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Castle.ActiveRecord.RelationAttribute"/> is lazy.
            </summary>
            <value><c>true</c> if lazy; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.Inverse">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Castle.ActiveRecord.RelationAttribute"/> is inverse.
            </summary>
            <value><c>true</c> if inverse; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.Cascade">
            <summary>
            Gets or sets the cascade options for this <see cref="T:Castle.ActiveRecord.RelationAttribute"/>
            </summary>
            <value>The cascade.</value>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.OrderBy">
            <summary>
            Gets or sets the order by clause for this relation. This is a SQL order, not HQL.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.Where">
            <summary>
            Gets or sets the where clause for this relation
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.Sort">
            <summary>
            Only used with sets. The value can be <c>unsorted</c>, <c>natural</c> and the name of a class implementing <c>System.Collections.IComparer</c>
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.Index">
            <summary>
            Only used with maps or lists
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.IndexType">
            <summary>
            Only used with maps
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.Element">
            <summary>
            Use for simple types.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.ElementType">
            <summary>
            Use for simple types.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.NotFoundBehaviour">
            <summary>
            Gets or sets the way broken relations are handled.
            </summary>
            <value>The behaviour.</value>
        </member>
        <member name="P:Castle.ActiveRecord.RelationAttribute.BatchSize">
            <summary>
            From NHibernate documentation:
            Specify a "batch size" for batch fetching of collections.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.HasAndBelongsToManyAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HasAndBelongsToManyAttribute"/> class.
            </summary>
            <param name="mapType">Type of the map.</param>
        </member>
        <member name="M:Castle.ActiveRecord.HasAndBelongsToManyAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HasAndBelongsToManyAttribute"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.HasAndBelongsToManyAttribute.#ctor(System.Type,Castle.ActiveRecord.RelationType)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HasAndBelongsToManyAttribute"/> class.
            </summary>
            <param name="mapType">Type of the map.</param>
            <param name="type">The type.</param>
        </member>
        <member name="P:Castle.ActiveRecord.HasAndBelongsToManyAttribute.ColumnRef">
            <summary>
            Gets or sets the column that represent the other side on the assoication table
            </summary>
            <value>The column ref.</value>
        </member>
        <member name="P:Castle.ActiveRecord.HasAndBelongsToManyAttribute.CompositeKeyColumnRefs">
            <summary>
            Gets or sets the composite key columns that represent the other side on the assoication table
            </summary>
            <value>The composite key column refs.</value>
        </member>
        <member name="P:Castle.ActiveRecord.HasAndBelongsToManyAttribute.ColumnKey">
            <summary>
            Gets or sets the key column name
            </summary>
            <value>The column key.</value>
        </member>
        <member name="P:Castle.ActiveRecord.HasAndBelongsToManyAttribute.CompositeKeyColumnKeys">
            <summary>
            Gets or sets the composite key columns names.
            </summary>
            <value>The composite key column keys.</value>
        </member>
        <member name="P:Castle.ActiveRecord.HasAndBelongsToManyAttribute.Fetch">
            <summary>
            Chooses between outer-join fetching
            or sequential select fetching.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.HasAndBelongsToManyAttribute.CollectionType">
            <summary>
            Provides a custom collection type.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.HasManyAttribute">
            <summary>
            Maps a one to many association.
            </summary>
            <example><code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[HasMany(typeof(Post), RelationType.Bag, ColumnKey="Posts", Table="Posts")]
            	public IList Posts
            	{
            		get { return _posts; }
            		set { _posts = value; }
            	}
            </code></example>
        </member>
        <member name="F:Castle.ActiveRecord.HasManyAttribute.keyColumn">
            <summary>
            The key column
            Cannot exist if compositeKeyColumns has a value
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.HasManyAttribute.compositeKeyColumns">
            <summary>
            The composite columns
            Cannot exist with keyColumn != null
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.HasManyAttribute.hasDependentObjects">
            <summary>
            Whether the target type is for dependent objects or not
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.HasManyAttribute.fetchMethod">
            <summary>
            Whether we do outer join fetching for this collection
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.HasManyAttribute.customCollectionType">
            <summary>
            Provides a custom collection type.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.HasManyAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HasManyAttribute"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.HasManyAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HasManyAttribute"/> class.
            </summary>
            <param name="mapType">Type of the map.</param>
        </member>
        <member name="M:Castle.ActiveRecord.HasManyAttribute.#ctor(System.Type,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HasManyAttribute"/> class.
            </summary>
            <param name="mapType">Type of items in this association</param>
            <param name="keyColumn">The key column.</param>
            <param name="table">The table.</param>
        </member>
        <member name="P:Castle.ActiveRecord.HasManyAttribute.ColumnKey">
            <summary>
            Gets or sets the key column name.
            </summary>
            <value>The column key.</value>
        </member>
        <member name="P:Castle.ActiveRecord.HasManyAttribute.CompositeKeyColumnKeys">
            <summary>
            Gets or sets the names of the column in composite key scenarios.
            </summary>
            <value>The composite key column keys.</value>
        </member>
        <member name="P:Castle.ActiveRecord.HasManyAttribute.DependentObjects">
            <summary>
            Whether or not the target type is a dependent object.
            </summary>
            <value>true = the target type is a dependent object</value>
        </member>
        <member name="P:Castle.ActiveRecord.HasManyAttribute.Fetch">
            <summary>
            Chooses between outer-join fetching
            or sequential select fetching.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.HasManyAttribute.CollectionType">
            <summary>
            Provides a custom collection type.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.HasManyToAnyAttribute">
            <summary>
            This attribute allows polymorphic association between classes that doesn't have a common root class.
            In require two columns that would tell it what is the type of the asssoicated entity, and what is the PK of that entity.
            <remarks>
            This is supplied for advanced sceanrios.
            </remarks>
            <example>
            For instnace, let assume that you have two classes (that implement a common interface, but have no base classs) called:
             - Back Account
             - Credit Card
            
            And you have a set of Payment methods, that can be either. You would define the mapping so:
            <code>
            [HasManyToAny(typeof(IPayment), "pay_id", "payments_table", typeof(int), "payment_type", "payment_method_id",
            	MetaType = typeof(int), RelationType = RelationType.Set)]
            </code>
            typeof(IPayement) - the common interface tha both classes implement, and the type of all the items in the set.
            "pay_id" - the column that hold the PK of this entity (the FK column)
            "payments_table" - the table that has the assoication information (in 1:M scenarios - usuaully the same table, in M:N scenarios the link table).
            typeof(int) - the type of id column 
            "payment_type" - the column used to find out which class is represented by this row.
            "payment_method_id" - the column that holds the PK of the assoicated class (either CreditCard or BankAccount).
            MetaType = typeof(int) - the type of the meta column (payment_type)
            RelationType = RelationType.Set - specify that we use a set here
            </example>
            
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.HasManyToAnyAttribute.#ctor(System.Type,System.String,System.String,System.Type,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HasManyToAnyAttribute"/> class.
            </summary>
            <param name="mapType">Type of the map.</param>
            <param name="keyColum">The key colum.</param>
            <param name="table">The table.</param>
            <param name="idType">Type of the id.</param>
            <param name="typeColumn">The type column.</param>
            <param name="idColumn">The id column.</param>
        </member>
        <member name="P:Castle.ActiveRecord.HasManyToAnyAttribute.TypeColumn">
            <summary>
            Gets or sets the type column.
            </summary>
            <value>The type column.</value>
        </member>
        <member name="P:Castle.ActiveRecord.HasManyToAnyAttribute.IdColumn">
            <summary>
            Gets or sets the id column.
            </summary>
            <value>The id column.</value>
        </member>
        <member name="P:Castle.ActiveRecord.HasManyToAnyAttribute.MetaType">
            <summary>
            Gets or sets the type of the meta column
            </summary>
            <value>The type of the meta.</value>
        </member>
        <member name="P:Castle.ActiveRecord.HasManyToAnyAttribute.IdType">
            <summary>
            Gets or sets the type of the id column
            </summary>
            <value>The type of the id.</value>
        </member>
        <member name="T:Castle.ActiveRecord.HiloAttribute">
            <summary>
            Used when a constraint requires a hilo algorithm 
            </summary>
            <example><code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[HasManyAndBelongs/HasMany,
            	CollectionID(CollectionIDAttribute.HiLo),
            	Hilo]
            	public int Id
            	{
            		get { return _id; }
            		set { _id = value; }
            	}
            </code></example>
        </member>
        <member name="M:Castle.ActiveRecord.HiloAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HiloAttribute"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.HiloAttribute.#ctor(System.String,System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.HiloAttribute"/> class.
            </summary>
            <param name="table">The table.</param>
            <param name="column">The column.</param>
            <param name="maxlo">The maxlo.</param>
        </member>
        <member name="P:Castle.ActiveRecord.HiloAttribute.Column">
            <summary>
            Gets or sets the column name
            </summary>
            <value>The column.</value>
        </member>
        <member name="P:Castle.ActiveRecord.HiloAttribute.Table">
            <summary>
            Gets or sets the table name
            </summary>
            <value>The table.</value>
        </member>
        <member name="P:Castle.ActiveRecord.HiloAttribute.MaxLo">
            <summary>
            Gets or sets the max low value
            </summary>
            <value>The max lo.</value>
        </member>
        <member name="T:Castle.ActiveRecord.HqlNamedQueryAttribute">
            <summary>
            This is used to define a named HQL query.
            It represents the &lt;query&gt; element.
            </summary>
            <example>
            [assembly: HqlNamedQuery("allAdultUsers", "from User where user.Age > 21")]
            </example>
        </member>
        <member name="M:Castle.ActiveRecord.HqlNamedQueryAttribute.#ctor(System.String,System.String)">
            <summary>
            Create a new instance
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.HqlNamedQueryAttribute.Name">
            <summary>
            The name of the query
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.HqlNamedQueryAttribute.Query">
            <summary>
            The query itself
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Attributes.IgnoreEventListenerAttribute">
            <summary>
             Instructs <see cref="T:Castle.ActiveRecord.ActiveRecordStarter"/> to ignore the event listeners 
             of the specified type or assembly. 
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Attributes.IgnoreEventListenerAttribute.#ctor(System.String)">
            <summary>
            Adds an assembly which event listeners should be ignored when added per <see cref="T:Castle.ActiveRecord.EventListenerAttribute"/>.
            </summary>
            <param name="assemblyName">The name of the assembly. A partial name is sufficient.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Attributes.IgnoreEventListenerAttribute.#ctor(System.Type)">
            <summary>
            Ignores the specified event listener.
            </summary>
            <param name="type">A type that implements at least one event listener interface.</param>
        </member>
        <member name="T:Castle.ActiveRecord.ImportAttribute">
            <summary>
            This is used to map between a type to a friendly name that can be used in the queries.
            
            This attribute is representing an &lt;import/&gt; in the mapping files
            </summary>
            <example>
            [Import(typeof(SummaryRow), "summary")]
            </example>
        </member>
        <member name="M:Castle.ActiveRecord.ImportAttribute.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ImportAttribute"/> class.
            </summary>
            <param name="type">The type.</param>
            <param name="rename">The rename.</param>
        </member>
        <member name="P:Castle.ActiveRecord.ImportAttribute.Type">
            <summary>
            Gets the type that is being imported
            </summary>
            <value>The type.</value>
        </member>
        <member name="P:Castle.ActiveRecord.ImportAttribute.Rename">
            <summary>
            Gets or sets the renamed string that will replace the full type name in HQL queries for the specified type.
            </summary>
            <value>The renamed value.</value>
        </member>
        <member name="T:Castle.ActiveRecord.JoinedBaseAttribute">
            <summary>
            Denotes that a class is the parent class of one or 
            more subclasses using a join
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.JoinedKeyAttribute">
            <summary>
            Used for joined subclasses.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.JoinedKeyAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.JoinedKeyAttribute"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.JoinedKeyAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.JoinedKeyAttribute"/> class.
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="P:Castle.ActiveRecord.JoinedKeyAttribute.Column">
            <summary>
            Gets or sets the column name
            </summary>
            <value>The column.</value>
        </member>
        <member name="T:Castle.ActiveRecord.JoinedTableAttribute">
            <summary>
            Associates another table with the mapping.
            </summary>
            <example>
            <code>
            [JoinedTable("tb_Address")]
            public class Order : ActiveRecordBase
            {
            }
            </code>
            </example>
        </member>
        <member name="M:Castle.ActiveRecord.JoinedTableAttribute.#ctor(System.String)">
            <summary>
             Joins the specified table with the target type.
            </summary>
            <param name="table"></param>
        </member>
        <member name="P:Castle.ActiveRecord.JoinedTableAttribute.Table">
            <summary>
            Gets or sets the table name joined with the type.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.JoinedTableAttribute.Schema">
            <summary>
            Gets or sets the schema name of the joined table.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.JoinedTableAttribute.Column">
            <summary>
            Defines the column used for joining (usually a foreign key)
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.JoinedTableAttribute.Fetch">
            <summary>
            Chooses between outer-join fetching
            or sequential select fetching.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.JoinedTableAttribute.Inverse">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Castle.ActiveRecord.JoinedTableAttribute"/> is inverse.
            </summary>
            <value><c>true</c> if inverse; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Castle.ActiveRecord.JoinedTableAttribute.Optional">
            <summary>
            Determines if the join is optional.
            <value><c>true</c> if optional; otherwise, <c>false</c>.</value>
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.KeyPropertyAttribute">
            <summary>
            A key property for a composite key
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.PropertyAttribute">
            <summary>
            Maps a standard column of the table.
            </summary>
            <example>
            In the following example, the column is also
            called 'name', so you don't have to specify.
            <code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[Property]
            	public int Name
            	{
            		get { return _name; }
            		set { _name = value; }
            	}
            </code>
            To map a column name, use 
            <code>
            	[Property("blog_name")]
            	public int Name
            	{
            		get { return _name; }
            		set { _name = value; }
            	}
            </code>
            </example>
        </member>
        <member name="M:Castle.ActiveRecord.PropertyAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.PropertyAttribute"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.PropertyAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.PropertyAttribute"/> class.
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="M:Castle.ActiveRecord.PropertyAttribute.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.PropertyAttribute"/> class.
            </summary>
            <param name="column">The column.</param>
            <param name="type">The type.</param>
        </member>
        <member name="P:Castle.ActiveRecord.PropertyAttribute.NotNull">
            <summary>
            Gets or sets a value indicating whether this property allow null.
            </summary>
            <value><c>true</c> if allow null; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Castle.ActiveRecord.PropertyAttribute.Length">
            <summary>
            Gets or sets the length of the property (for strings - nvarchar(50) )
            </summary>
            <value>The length.</value>
        </member>
        <member name="P:Castle.ActiveRecord.PropertyAttribute.Column">
            <summary>
            Gets or sets the column name
            </summary>
            <value>The column.</value>
        </member>
        <member name="P:Castle.ActiveRecord.PropertyAttribute.Update">
            <summary>
            Set to <c>false</c> to ignore this property when updating entities of this ActiveRecord class.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.PropertyAttribute.Insert">
            <summary>
            Set to <c>false</c> to ignore this property when inserting entities of this ActiveRecord class.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.PropertyAttribute.Unique">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Castle.ActiveRecord.PropertyAttribute"/> is unique.
            </summary>
            <value><c>true</c> if unique; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Castle.ActiveRecord.PropertyAttribute.Formula">
            <summary>
            Gets or sets the formula used to calculate this property
            </summary>
            <value>The formula.</value>
        </member>
        <member name="P:Castle.ActiveRecord.PropertyAttribute.ColumnType">
            <summary>
            Gets or sets the type of the column.
            </summary>
            <value>The type of the column.</value>
        </member>
        <member name="P:Castle.ActiveRecord.PropertyAttribute.UniqueKey">
            <summary>
            From NHibernate documentation:
            A unique-key attribute can be used to group columns 
            in a single unit key constraint. 
            </summary>
            <value>unique key name</value>
            <remarks>
            Currently, the 
            specified value of the unique-key attribute is not 
            used to name the constraint, only to group the columns 
            in the mapping file.
            </remarks>
        </member>
        <member name="P:Castle.ActiveRecord.PropertyAttribute.Index">
            <summary>
            From NHibernate documentation:
            specifies the name of a (multi-column) index
            </summary>
            <value>index name</value>
        </member>
        <member name="P:Castle.ActiveRecord.PropertyAttribute.SqlType">
            <summary>
            From NHibernate documentation:
            overrides the default column type
            </summary>
            <value>column_type</value>
        </member>
        <member name="P:Castle.ActiveRecord.PropertyAttribute.Check">
            <summary>
            From NHibernate documentation:
            create an SQL check constraint on either column or table
            </summary>
            <value>Sql Expression</value>
        </member>
        <member name="P:Castle.ActiveRecord.PropertyAttribute.Default">
            <summary>
            Gets or sets the default value for a column (used by schema generation). 
            Please note that you should be careful to set Insert=false or set the value to the same 
            as the default on the database. 
            </summary>
            <value>The default value for the column.</value>
        </member>
        <member name="P:Castle.ActiveRecord.PropertyAttribute.IsOverride">
            <summary>
            Set to <c>true</c> if this property overrides a property in a base class
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.KeyPropertyAttribute.UnsavedValue">
            <summary>
            Gets or sets the unsaved value.
            </summary>
            <value>The unsaved value.</value>
        </member>
        <member name="T:Castle.ActiveRecord.NestedAttribute">
            <summary>
            Maps properties of a child object to columns of the table 
            of a parent class.
            </summary>
            <example>
            The following code illustrates the use of a 
            nested <c>PostalAddress</c> class
            <code>
            	[ActiveRecord("Companies")]
            	public class Company : ActiveRecordBase
            	{
            		private int id;
            		private PostalAddress _address;
            	
            		public Company()
            		{
            		}
            	
            		public Company(string name)
            		{
            			this.name = name;
            		}
            	
            		[PrimaryKey]
            		public int Id
            		{
            			get { return id; }
            			set { id = value; }
            		}
            	
            		[Nested]
            		public PostalAddress Address
            		{
            			get { return _address; }
            			set { _address = value; }
            		}
            	}
            	
            	public class PostalAddress
            	{
            		private String _address;
            		private String _city;
            		private String _state;
            		private String _zipcode;
            	
            		[Property]
            		public String Address
            		{
            			get { return _address; }
            			set { _address = value; }
            		}
            	
            		[Property]
            		public String City
            		{
            			get { return _city; }
            			set { _city = value;}
            		}
            	
            		[Property]
            		public String State
            		{
            			get { return _state; }
            			set { _state = value; }
            		}
            	
            		[Property]
            		public String ZipCode
            		{
            			get { return _zipcode; }
            			set { _zipcode = value; }
            		}
            	}
            </code>
            </example>
        </member>
        <member name="M:Castle.ActiveRecord.NestedAttribute.#ctor">
            <summary>
            Informs ActiveRecord that the marked property contains nested elements, contained
            in a separate, reusable class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.NestedAttribute.#ctor(System.String)">
            <summary>
            Informs ActiveRecord that the marked property contains nested elements, contained
            in a separate, reusable class.
            </summary>
            <param name="columnPrefix">A prefix to insert before each column in the nested component</param>
        </member>
        <member name="P:Castle.ActiveRecord.NestedAttribute.MapType">
            <summary>
            Allows one to reference a different type
            than the property type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.NestedAttribute.Update">
            <summary>
            Set to <c>false</c> to ignore this nested component when updating entities of this ActiveRecord class.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.NestedAttribute.Insert">
            <summary>
            Set to <c>false</c> to ignore this nested component when inserting entities of this ActiveRecord class.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.NestedAttribute.ColumnPrefix">
            <summary>
            A prefix to insert before each column in the nested component.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.NestedParentReferenceAttribute">
             <summary>
             Maps a property of a child object to its parent object.
             </summary>
             <example>
             The following code illustrates the use of a 
             parent <c>Company</c> class
             <code>
                 public class PostalAddress
             	{
                     private Company _company;
             		private String _address;
             		private String _city;
             		private String _state;
             		private String _zipcode;
             	
                     [Parent]
                     public Company Parent
                     {
                         get { return _company; }
                         set { _company = value; }
                     }
            
             		[Property]
             		public String Address
             		{
             			get { return _address; }
             			set { _address = value; }
             		}
             	
             		[Property]
             		public String City
             		{
             			get { return _city; }
             			set { _city = value;}
             		}
             	
             		[Property]
             		public String State
             		{
             			get { return _state; }
             			set { _state = value; }
             		}
             	
             		[Property]
             		public String ZipCode
             		{
             			get { return _zipcode; }
             			set { _zipcode = value; }
             		}
             	}
            
             	[ActiveRecord("Companies")]
             	public class Company : ActiveRecordBase
             	{
             		private int id;
             		private PostalAddress _address;
             	
             		public Company()
             		{
             		}
             	
             		public Company(string name)
             		{
             			this.name = name;
             		}
             	
             		[PrimaryKey]
             		public int Id
             		{
             			get { return id; }
             			set { id = value; }
             		}
             	
             		[Nested]
             		public PostalAddress Address
             		{
             			get { return _address; }
             			set { _address = value; }
             		}
             	}
             </code>
             </example>
        </member>
        <member name="M:Castle.ActiveRecord.NestedParentReferenceAttribute.#ctor">
            <summary>
            Informs ActiveRecord that the marked property is the parent of a nested element
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.OneToOneAttribute">
            <summary>
            Associates a foreign table where the current class
            and the target class share their primary key.
            </summary>
            <example>
            The following code exemplifies two classes that maps 
            to two tables sharing the primary key:
            <code>
            	[ActiveRecord("Employee")]
            	public class Employee : ActiveRecordBase
            	{
            		private int id;
            		private Award award;
            	
            		[PrimaryKey(PrimaryKeyType.Native, "EmployeeID")]
            		public int ID
            		{
            			get { return this.id; }
            			set { this.id = value; }
            		}
            	
            		[OneToOne]
            		public Award Award
            		{
            			get { return this.award; }
            			set { this.award = value; }
            		}
            	}
            	
            	[ActiveRecord("Award")]
            	public class Award : ActiveRecordBase
            	{
            		private Employee employee;
            		private int id;
            	
            		public Award()
            		{
            		}
            	
            		public Award(Employee employee)
            		{
            			this.employee = employee;
            		}
            	
            		[OneToOne]
            		public Employee Employee
            		{
            			get { return this.employee; }
            			set { this.employee = value; }
            		}
            	
            		[PrimaryKey(PrimaryKeyType.Foreign, "EmployeeID")]
            		public int ID
            		{
            			get { return this.id; }
            			set { this.id = value; }
            		}
            	
            		public static Award[] FindAll()
            		{
            			return ((Award[]) (ActiveRecordBase.FindAll(typeof(Award))));
            		}
            	
            		public static void DeleteAll()
            		{
            			ActiveRecordBase.DeleteAll( typeof(Award) );
            		}
            	}
            	Employee emp = new Employee();
            	emp.Name = "john doe";
            	emp.Save();
            	
            	Award award = new Award(emp);
            	award.Description = "Invisible employee";
            	award.Save();
            </code>
            </example>
            <remarks>
            Usually classes that uses the primary key
            generated elsewhere (foreign) uses the PrimaryKey attribute with the
            generator type <c>PrimaryKeyType.Foreign</c>
            </remarks>
        </member>
        <member name="P:Castle.ActiveRecord.OneToOneAttribute.MapType">
            <summary>
            Allows one to reference a different type
            than the property type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.OneToOneAttribute.Cascade">
            <summary>
            From NHibernate docs: specifies which operations should be 
            cascaded from the parent object to the associated object.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.OneToOneAttribute.Fetch">
            <summary>
            From NHibernate docs: Chooses between outer-join fetching 
            or sequential select fetching.
            </summary>
            <remarks>
            Defaults to <see cref="F:Castle.ActiveRecord.FetchEnum.Select"/>
            </remarks>
        </member>
        <member name="P:Castle.ActiveRecord.OneToOneAttribute.PropertyRef">
            <summary>
            From NHibernate docs: The name of a property of the 
            associated class that is joined to the primary key 
            of this class. If not specified, the primary key of 
            the associated class is used.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.OneToOneAttribute.Constrained">
            <summary>
            From NHibernate docs: specifies that a foreign key 
            constraint on the primary key of the mapped table 
            references the table of the associated class. 
            This option affects the order in which Save() and 
            Delete() are cascaded (and is also used by the 
            schema export tool).
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.OneToOneAttribute.ForeignKey">
            <summary>
            Gets or sets the name of the foreign key constraint generated for 
            an association. NHibernate will only use the ForeignKey name one 
            the inherited class and Constrained = true.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.PrimaryKeyType">
            <summary>
            Define the possible strategies to set the Primary Key values
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.PrimaryKeyType.Identity">
            <summary>
            Use Identity column (auto number)
            Note: This force an immediate call to the DB when Create() is called
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.PrimaryKeyType.Sequence">
            <summary>
            Use a sequence
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.PrimaryKeyType.HiLo">
            <summary>
            Use the HiLo algorithm to get the next value
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.PrimaryKeyType.SeqHiLo">
            <summary>
            Use a sequence and a HiLo algorithm - better performance on Oracle
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.PrimaryKeyType.UuidHex">
            <summary>
            Use the hex representation of a unique identifier
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.PrimaryKeyType.UuidString">
            <summary>
            Use the string representation of a unique identifier
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.PrimaryKeyType.Guid">
            <summary>
            Generate a Guid for the primary key
            Note: You should prefer using GuidComb over this value.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.PrimaryKeyType.GuidComb">
            <summary>
            Generate a Guid in sequence, so it will have better insert performance in the DB.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.PrimaryKeyType.Native">
            <summary>
            Use an identity or sequence if supported by the database, otherwise, use the HiLo algorithm
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.PrimaryKeyType.Assigned">
            <summary>
            The primary key value is always assigned.
            Note: using this you will lose the ability to call Save(), and will need to call Create() or Update()
            explicitly.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.PrimaryKeyType.Foreign">
            <summary>
            This is a foreign key to another table
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.PrimaryKeyType.Counter">
            <summary>
            Returns a <c>Int64</c> constructed from the system
            time and a counter value.
            </summary>
            <remarks>
            Not safe for use in a clustser
            </remarks>
        </member>
        <member name="F:Castle.ActiveRecord.PrimaryKeyType.Increment">
            <summary>
            Returns a <c>Int64</c>, constructed by counting from 
            the maximum primary key value at startup. 
            </summary>
            <remarks>
            Not safe for use in a cluster
            </remarks>
        </member>
        <member name="F:Castle.ActiveRecord.PrimaryKeyType.Custom">
            <summary>
            A custom generator will be provided. See <see cref="P:Castle.ActiveRecord.PrimaryKeyAttribute.CustomGenerator"/>
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.PrimaryKeyAttribute">
            <summary>
            Indicates the property which is the primary key.
            </summary>
            <example><code>
            public class Blog : ActiveRecordBase
            {
            	...
            	
            	[PrimaryKey(PrimaryKeyType.Native)]
            	public int Id
            	{
            		get { return _id; }
            		set { _id = value; }
            	}
            </code></example>
        </member>
        <member name="M:Castle.ActiveRecord.PrimaryKeyAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.PrimaryKeyAttribute"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.PrimaryKeyAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.PrimaryKeyAttribute"/> class.
            </summary>
            <param name="customGenerator">A custom identifier 
            generator (that implements <see cref="T:NHibernate.Id.IIdentifierGenerator"/>).</param>
        </member>
        <member name="M:Castle.ActiveRecord.PrimaryKeyAttribute.#ctor(Castle.ActiveRecord.PrimaryKeyType)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.PrimaryKeyAttribute"/> class.
            </summary>
            <param name="generator">The generator.</param>
        </member>
        <member name="M:Castle.ActiveRecord.PrimaryKeyAttribute.#ctor(Castle.ActiveRecord.PrimaryKeyType,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.PrimaryKeyAttribute"/> class.
            </summary>
            <param name="generator">The generator.</param>
            <param name="column">The PK column.</param>
        </member>
        <member name="M:Castle.ActiveRecord.PrimaryKeyAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.PrimaryKeyAttribute"/> class.
            </summary>
            <param name="column">The PK column.</param>
        </member>
        <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.Generator">
            <summary>
            Gets or sets the generator.
            </summary>
            <value>The generator.</value>
        </member>
        <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.Column">
            <summary>
            Gets or sets the column name
            </summary>
            <value>The column.</value>
        </member>
        <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.UnsavedValue">
            <summary>
            Gets or sets the unsaved value.
            </summary>
            <value>The unsaved value.</value>
        </member>
        <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.SequenceName">
            <summary>
            Gets or sets the name of the sequence.
            </summary>
            <value>The name of the sequence.</value>
        </member>
        <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.ColumnType">
            <summary>
            Gets or sets the type of the column.
            </summary>
            <value>The type of the column.</value>
        </member>
        <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.Length">
            <summary>
            Gets or sets the length of values in the column
            </summary>
            <value>The length.</value>
        </member>
        <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.CustomGenerator">
            <summary>
            Gets or sets the custom generator. 
            The generator must implement <see cref="T:NHibernate.Id.IIdentifierGenerator"/>
            </summary>
            <value>The custom generator type.</value>
        </member>
        <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.Params">
            <summary>
            Comma separated value of parameters to the generator
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.PrimaryKeyAttribute.IsOverride">
            <summary>
            Set to <c>true</c> if this primary key overrides a primary key in a base class
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.PropertyAccess">
            <summary>
            Define the various access strategies NHibernate will use to set/get the value
            for this property.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.PropertyAccess.Property">
            <summary>
            Use the property get/set methods to get and set the value of this property
            </summary>
            <example>
            <code>
            [Property(Access=PropertyAccess.Property)]
            public string UserName { get {... } set { ... } }
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.PropertyAccess.Field">
            <summary>
            Use the field to get/set the value. (Only valid when specify on a field).
            </summary>
            <example>
            <code>
            [Property(Access=PropertyAccess.Field)]
            public string UserName; // notice this is a field, not property.
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.PropertyAccess.AutomaticProperty">
            <summary>
            Use the backing field of this property to get/set the value. (Only valid when specified on automatic property)
            </summary>
            <example>
            <code>
            [Property(Access=PropertyAccess.AutomaticProperty)]
            public string UserName { get; set; } // notice this is automatic property
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.PropertyAccess.ReadOnly">
            <summary>
            Use the property get method to get the value of this property. Property will be only read, never written.
            </summary>
            <example>
            <code>
            [Property(Access=PropertyAccess.ReadOnly)]
            public string SumOfAllOrders { get { orders.Sum( o => o.Value ); }
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.PropertyAccess.FieldCamelcase">
            <summary>
            Use the field that is the backing store for this property to get/set the value of this property.
            The field is using the same name as the property, in camel case.
            </summary>
            <example>
            <code>
            string userName;//this will be use to get or set the value
            
            [Property(Access=PropertyAccess.FieldCamelCase)]
            public string UserName { get {... } set { ... } }
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.PropertyAccess.FieldCamelcaseUnderscore">
            <summary>
            Use the field that is the backing store for this property to get/set the value of this property.
            The field is using the same name as the property, in camel case and with an initial underscore
            </summary>
            <example>
            <code>
            string _userName;//this will be use to get or set the value
            
            [Property(Access=PropertyAccess.FieldCamelcaseUnderscore)]
            public string UserName { get {... } set { ... } }
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.PropertyAccess.FieldPascalcaseMUnderscore">
            <summary>
            Use the field that is the backing store for this property to get/set the value of this property.
            The field is using the same name as the property, in pascal case and with an initial m and then underscore.
            m_Name for the property Name.
            </summary>
            <example>
            <code>
            string m_UserName;//this will be use to get or set the value
            
            [Property(Access=PropertyAccess.FieldPascalcaseMUnderscore)]
            public string UserName { get {... } set { ... } }
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.PropertyAccess.FieldLowercaseUnderscore">
            <summary>
            Use the field that is the backing store for this property to get/set the value of this property.
            The field is using the same name as the property, in all lower case and with inital underscore
            </summary>
            <example>
            <code>
            string _username;//this will be use to get or set the value
            
            [Property(Access=PropertyAccess.FieldLowercaseUnderscore)]
            public string UserName { get {... } set { ... } }
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.PropertyAccess.NosetterCamelcase">
            <summary>
            Use the property' getter to get the value, and use the field with the same name and in camel case
            in order to set it.
            </summary>
            <example>
            <code>
            string _userName;//this will be use to set the value
            
            [Property(Access=PropertyAccess.NosetterCamelcase)]
            public string UserName { get {... } set { ... } } // this will be used just to get the value
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.PropertyAccess.NosetterCamelcaseUnderscore">
            <summary>
            Use the property' getter to get the value, and use the field with the same name and in camel case
            with initial "_" in order to set it.
            </summary>
            <example>
            <code>
            string _userName;//this will be use to set the value
            
            [Property(Access=PropertyAccess.NosetterCamelcaseUnderscore)]
            public string UserName { get {... } set { ... } } // this will be used just to get the value
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.PropertyAccess.NosetterPascalcaseUnderscore">
            <summary>
            Use the property' getter to get the value, and use the field with the same name and in pascal case
            with initial "_" in order to set it.
            </summary>
            <example>
            <code>
            string _UserName;//this will be use to set the value
            
            [Property(Access=PropertyAccess.NosetterPascalcaseUnderscore)]
            public string UserName { get {... } set { ... } } // this will be used just to get the value
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.PropertyAccess.NosetterPascalcaseMUndersc">
            <summary>
            Use the property' getter to get the value, and use the field with the same name and in pascal case
            with initial "m_" in order to set it.
            </summary>
            <example>
            <code>
            string m_UserName;//this will be use to set the value
            
            [Property(Access=PropertyAccess.NosetterPascalcaseMUndersc)]
            public string UserName { get {... } set { ... } } // this will be used just to get the value
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.PropertyAccess.NosetterLowercaseUnderscore">
            <summary>
            Use the property' getter to get the value, and use the field with the same name and in lower case
            with initial "_" in order to set it.
            </summary>
            <example>
            <code>
            string _username;//this will be use to set the value
            
            [Property(Access=PropertyAccess.NosetterLowercaseUnderscore)]
            public string UserName { get {... } set { ... } } // this will be used just to get the value
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.PropertyAccess.NosetterLowercase">
            <summary>
            Use the property' getter to get the value, and use the field with the same name and in lower case
            in order to set it.
            </summary>
            <example>
            <code>
            string username;//this will be use to set the value
            
            [Property(Access=PropertyAccess.NosetterLowercase)]
            public string UserName { get {... } set { ... } } // this will be used just to get the value
            </code>
            </example>
        </member>
        <member name="T:Castle.ActiveRecord.PropertyAccessHelper">
            <summary>
            Utility class to help convert between <see cref="T:Castle.ActiveRecord.PropertyAccess"/> values and
            NHiberante's access strategies.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.PropertyAccessHelper.ToString(Castle.ActiveRecord.PropertyAccess)">
            <summary>
            Convert <param name="access"/> to its NHibernate string 
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.RawXmlMappingAttribute">
            <summary>
            Abstract base class for custom attributes that can generate XML and return it directly.
            This allows to customize the generate the XML passed to NHibernate in a flexible way.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.RawXmlMappingAttribute.GetMappings">
            <summary>
            Get the mapping xml to add to NHibernate's configuration.
            Note that we allow to return more than a single mapping, each string is 
            treated as a seperated document.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.RelationType">
            <summary>
            Define the relation type for a relation.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.RelationType.Guess">
            <summary>
            Let Active Record guess what is the type of the relation.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.RelationType.Bag">
            <summary>
            An bag of items (allow duplicates)
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.RelationType.Set">
            <summary>
            A set of unique items
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.RelationType.IdBag">
            <summary>
            A bag of items with id
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.RelationType.Map">
            <summary>
            Map of key/value pairs (IDictionary)
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.RelationType.List">
            <summary>
            A list of items - position in the list has meaning
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.SqlNamedQueryAttribute">
            <summary>
            This is used to define a named SQL query.
            It represents the &lt;query&gt; element.
            </summary>
            <example>
            [assembly: SqlNamedQuery("allAdultUsers", "select * from User where Age > 21")]
            </example>
        </member>
        <member name="M:Castle.ActiveRecord.SqlNamedQueryAttribute.#ctor(System.String,System.String)">
            <summary>
            Create a new instance
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.SqlNamedQueryAttribute.Name">
            <summary>
            The name of the query
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.SqlNamedQueryAttribute.Query">
            <summary>
            The query itself
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.TimestampAttribute">
            <summary>
            Specify that this property is used for timestamping this entity
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.TimestampAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.TimestampAttribute"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.TimestampAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.TimestampAttribute"/> class.
            </summary>
            <param name="column">The column name</param>
        </member>
        <member name="P:Castle.ActiveRecord.TimestampAttribute.Column">
            <summary>
            Gets or sets the column name
            </summary>
            <value>The column.</value>
        </member>
        <member name="T:Castle.ActiveRecord.VersionAttribute">
            <summary>
            This attribute is used to specify that a property is the versioning property of the class
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.VersionAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.VersionAttribute"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.VersionAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.VersionAttribute"/> class.
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="P:Castle.ActiveRecord.VersionAttribute.Column">
            <summary>
            Gets or sets the column name
            </summary>
            <value>The column.</value>
        </member>
        <member name="P:Castle.ActiveRecord.VersionAttribute.Type">
            <summary>
            Gets or sets the type of the column (should be an integer of some type)
            </summary>
            <value>The type.</value>
        </member>
        <member name="P:Castle.ActiveRecord.VersionAttribute.UnsavedValue">
            <summary>
            Gets or sets the unsaved value for this column
            </summary>
            <value>The unsaved value.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Config.ActiveRecordSectionHandler">
            <summary>
            Reads the configuration from a entry 'activerecord'
            in the xml associated with the AppDomain
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource">
            <summary>
            Source of configuration based on Xml 
            source like files, streams or readers.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource">
            <summary>
            Usefull for test cases.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.IConfigurationSource">
            <summary>
            Abstracts the source of configuration for the framework.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.IConfigurationSource.GetConfiguration(System.Type)">
            <summary>
            Implementors should return an <see cref="T:Castle.Core.Configuration.IConfiguration"/> 
            instance
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.ThreadScopeInfoImplementation">
            <summary>
            Implementors should return the type that implements
            the interface <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/>
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.SessionFactoryHolderImplementation">
            <summary>
            Implementors should return the type that implements 
            the interface <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.NamingStrategyImplementation">
            <summary>
            Implementors should return the type that implements
            the interface NHibernate.Cfg.INamingStrategy
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.Debug">
            <summary>
            Gets a value indicating whether this <see cref="T:Castle.ActiveRecord.Framework.IConfigurationSource"/> produce debug information
            </summary>
            <value><c>true</c> if debug; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.IsLazyByDefault">
            <summary>
            Gets a value indicating whether the entities should be lazy by default.
            </summary>
            <value>
            	<c>true</c> if entities should be lazy by default; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.PluralizeTableNames">
            <summary>
            Gets a value indicating whether table names are assumed plural by default. 
            </summary>
            <value>
            	<c>true</c> if table names should be pluralized by default; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.VerifyModelsAgainstDBSchema">
            <summary>
            Gets or sets a value indicating whether the models should be verified against the db schema on Initialisation.
            </summary>
            <value>
            	<c>true</c> if models should be verified; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.DefaultFlushType">
            <summary>
            Determines the default flushing behaviour of scopes.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IConfigurationSource.Searchable">
            <summary>
            When <c>true</c>, NHibernate.Search event listeners are added. 
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.GetConfiguration(System.Type)">
            <summary>
            Return an <see cref="T:Castle.Core.Configuration.IConfiguration"/> for the specified type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.BuildForMSSqlServer(System.String,System.String)">
            <summary>
            Builds a InPlaceConfigurationSource set up to access a MS SQL server database using integrated security.
            </summary>
            <param name="server">The server.</param>
            <param name="initialCatalog">The initial catalog.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.BuildForMSSqlServer(System.String,System.String,System.String,System.String)">
            <summary>
            Builds a InPlaceConfigurationSource set up to access a MS SQL server database using the specified username and password.
            </summary>
            <param name="server">The server.</param>
            <param name="initialCatalog">The initial catalog.</param>
            <param name="username">The username.</param>
            <param name="password">The password.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.Build(Castle.ActiveRecord.Framework.Config.DatabaseType,System.String)">
            <summary>
            Builds an <see cref="T:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource"/> for the specified database.
            </summary>
            <param name="database">The database type.</param>
            <param name="connectionString">The connection string.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.Add(System.Type,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Adds the specified type with the properties
            </summary>
            <param name="type">The type.</param>
            <param name="properties">The properties.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.Add(System.Type,Castle.Core.Configuration.IConfiguration)">
            <summary>
            Adds the specified type with configuration
            </summary>
            <param name="type">The type.</param>
            <param name="config">The config.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SetUpThreadInfoType(System.Boolean,System.String)">
            <summary>
            Sets the type of the thread info.
            </summary>
            <param name="isWeb">If we are running in a web context.</param>
            <param name="customType">The type of the custom implementation.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SetUpSessionFactoryHolderType(System.String)">
            <summary>
            Sets the type of the session factory holder.
            </summary>
            <param name="customType">Custom implementation</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SetUpNamingStrategyType(System.String)">
            <summary>
            Sets the type of the naming strategy.
            </summary>
            <param name="customType">Custom implementation type name.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SetDebugFlag(System.Boolean)">
            <summary>
            Sets the debug flag.
            </summary>
            <param name="isDebug">If set to <c>true</c> ActiveRecord will produce debug information.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SetIsLazyByDefault(System.Boolean)">
            <summary>
            Set whatever entities are lazy by default or not.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SetVerifyModelsAgainstDBSchema(System.Boolean)">
            <summary>
            Sets the flag to indicate if ActiveRecord should verify models against the database schema on startup.
            </summary>
            <param name="verifyModelsAgainstDBSchema">If set to <c>true</c> ActiveRecord will verify the models against the db schema on startup.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SetPluralizeTableNames(System.Boolean)">
            <summary>
            Sets the pluralizeTableNames flag.
            </summary>
            <param name="pluralize">If set to <c>true</c> ActiveRecord will pluralize inferred table names.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SetDefaultFlushType(Castle.ActiveRecord.Framework.DefaultFlushType)">
            <summary>
            Sets the value indicating the default flush behaviour.
            </summary>
            <param name="flushType">The chosen default behaviour.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SetDefaultFlushType(System.String)">
            <summary>
            Sets the default flushing behaviour using the string value from the configuration
            XML. This method has been moved from XmlConfigurationSource to avoid code
            duplication in ActiveRecordIntegrationFacility.
            </summary>
            <param name="configurationValue">The configuration value.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.ProcessConfiguration(Castle.Core.Configuration.IConfiguration)">
            <summary>
            Processes the configuration applying any substitutions.
            </summary>
            <param name="config">The configuration to process.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.ThreadScopeInfoImplementation">
            <summary>
            Return a type that implements
            the interface <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/>
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.SessionFactoryHolderImplementation">
            <summary>
            Return a type that implements
            the interface <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.NamingStrategyImplementation">
            <summary>
            Return a type that implements
            the interface NHibernate.Cfg.INamingStrategy
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.Debug">
            <summary>
            Gets a value indicating whether this <see cref="T:Castle.ActiveRecord.Framework.IConfigurationSource"/> produces debug information.
            </summary>
            <value><c>true</c> if debug; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.IsLazyByDefault">
            <summary>
            Gets a value indicating whether the entities should be lazy by default.
            </summary>
            <value>
            	<c>true</c> if entities should be lazy by default; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.PluralizeTableNames">
            <summary>
            Gets a value indicating whether table names are assumed plural by default. 
            </summary>
            <value>
            	<c>true</c> if table names should be pluralized by default; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.VerifyModelsAgainstDBSchema">
            <summary>
            Gets or sets a value indicating whether the models should be verified against the db schema on initialisation.
            </summary>
            <value>
            	<c>true</c> if models should be verified; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.DefaultFlushType">
            <summary>
            Determines the default flushing behaviour of scopes.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.Searchable">
            <summary>
            When <c>true</c>, NHibernate.Search event listeners are added.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource.IsRunningInWebApp">
            <summary>
            Sets a value indicating whether this instance is running in web app.
            </summary>
            <value>
            	<c>true</c> if this instance is running in web app; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource"/> class.
            </summary>
            <param name="xmlFileName">Name of the XML file.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource"/> class.
            </summary>
            <param name="stream">The stream.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource.#ctor(System.IO.TextReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource"/> class.
            </summary>
            <param name="reader">The reader.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource.PopulateSource(System.Xml.XmlNode)">
            <summary>
            Populate this instance with values from the given XML node
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource.SetDefaults(System.String,System.String)">
            <summary>
            Sets the default configuration for database specifiend by <paramref name="name"/>.
            </summary>
            <param name="name">Name of the database type.</param>
            <param name="connectionStringName">name of the connection string specified in connectionStrings configuration section</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.XmlConfigurationSource.BuildProperties(System.Xml.XmlNode,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Builds the configuration properties.
            </summary>
            <param name="node">The node.</param>
            <param name="defaults"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.ActiveRecordSectionHandler.Create(System.Object,System.Object,System.Xml.XmlNode)">
            <summary>
            Creates a configuration section handler.
            </summary>
            <param name="parent"></param>
            <param name="configContext">Configuration context object.</param>
            <param name="section"></param>
            <returns>The created section handler object.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.ActiveRecordSectionHandler.GetInstance">
            <summary>
            Returns the sole instance through a factory method for use with 
            Spring.Net (see AR-ISSUE-213)
            </summary>
            <returns>the sole instance</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Config.ActiveRecordSectionHandler.Instance">
            <summary>
            Gets the sole instance.
            </summary>
            <value>The instance.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Config.DatabaseType">
            <summary>
            Enum for database types support for configuration construction. 
            Not to be confused by databases supported by ActiveRecord
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Config.DatabaseType.MsSqlServer2000">
            <summary>
            Microsoft SQL Server 2000
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Config.DatabaseType.MsSqlServer2005">
            <summary>
            Microsoft SQL Server 2005
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Config.DatabaseType.MsSqlServer2008">
            <summary>
            Microsoft SQL Server 2008
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Config.DatabaseType.SQLite">
            <summary>
            SQLite
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Config.DatabaseType.MySql">
            <summary>
            MySQL 3 or 4
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Config.DatabaseType.MySql5">
            <summary>
            MySQL 5
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Config.DatabaseType.Firebird">
            <summary>
            Firebird
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Config.DatabaseType.PostgreSQL">
            <summary>
            PostgreSQL
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Config.DatabaseType.PostgreSQL81">
            <summary>
            PostgreSQL 8.1
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Config.DatabaseType.PostgreSQL82">
            <summary>
            PostgreSQL 8.2
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Config.DatabaseType.MsSqlCe">
            <summary>
            Microsoft SQL Server 2005 Compact Edition
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Config.DatabaseType.Oracle8i">
            <summary>
            Oracle 
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Config.DatabaseType.Oracle9i">
            <summary>
            Oracle 9
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Config.DatabaseType.Oracle10g">
            <summary>
            Oracle 10g
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Config.DefaultDatabaseConfiguration">
            <summary>
            Exposes default configuration properties for common databases defined in <see cref="T:Castle.ActiveRecord.Framework.Config.DatabaseType"/> enum.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Config.DefaultDatabaseConfiguration.For(Castle.ActiveRecord.Framework.Config.DatabaseType)">
            <summary>
            Returns dictionary of common properties pre populated with default values for given <paramref name="databaseType"/>.
            </summary>
            <param name="databaseType">Database type for which we want default properties.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.DefaultFlushType">
            <summary>
            Determines the default flushing behaviour of <see cref="T:Castle.ActiveRecord.SessionScope"/>
            and <see cref="T:Castle.ActiveRecord.TransactionScope"/>
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.DefaultFlushType.Classic">
            <summary>
            Classic flushing behaviour like in RC3 and before. <see cref="T:Castle.ActiveRecord.SessionScope"/>
            flushes automatically, <see cref="T:Castle.ActiveRecord.TransactionScope"/> flushes on Disposal if
            the transaction was committed.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.DefaultFlushType.Auto">
            <summary>
            New recommended behaviour. Both types of scope flush automatically, consolidating behaviour between
            scoped and non-scoped code.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.DefaultFlushType.Leave">
            <summary>
            Both scope types do only flush on disposal.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.DefaultFlushType.Transaction">
            <summary>
            NH2.0-alike behaviour. The <see cref="T:Castle.ActiveRecord.SessionScope"/> won't flush at all unless
            called manually. <see cref="T:Castle.ActiveRecord.TransactionScope"/> flushes automatically. This
            allows to use the scopes like the NH-ISession-ITransaction-block.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig">
            <summary>
            A configuration class for event listeners
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig.#ctor(System.Type)">
            <summary>
            Creates an instance for the given type
            </summary>
            <param name="listenerType">The listener type to use</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig.#ctor(System.Object)">
            <summary>
            Creates an instance for the given instance
            </summary>
            <param name="listenerInstance">The listener object to use</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig.CreateSingletonInstance">
            <summary>
            Creates the singleton instance. If the instance is already set, the method does not replace it.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig.SetSingletonInstance(System.Object)">
            <summary>
            Sets the singleton instance. If the instance is already set, the method does not replace it.
            </summary>
            <param name="instance">the instance to set</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig.Equals(System.Object)">
            <summary>
            Compares the instance with another one for equality.
            </summary>
            <param name="obj">The config to compare with</param>
            <returns>true if the obj is for the same <see cref="P:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig.ListenerType"/></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig.GetHashCode">
            <summary>
            Object infrastructure
            </summary>
            <returns>The hashcode</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig.ReplaceExisting">
            <summary>
            Whether to replace existing listeners 
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig.Ignore">
            <summary>
            Whether to ignore the listener completely
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig.SkipEvent">
            <summary>
            Defines that a single event should be skipped although it is defined in the
            listener
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig.Singleton">
            <summary>
            Specifies that all events for all configurations should be served by a single instance
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig.Include">
            <summary>
            Defines the base types for which the listener will be added.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig.Exclude">
            <summary>
            Defines the base types for which the listener will not be added.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig.ListenerType">
            <summary>
            The type of the listener
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig.ListenerInstance">
            <summary>
            The specific instance to use. If <code>null</code> then a new instance of the
            configured <see cref="P:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig.ListenerType"/> will be created.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerContributor">
            <summary>
            This contributor supports the complex configuration of event listeners.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.AbstractNHContributor">
            <summary>
            Defines an abstract base class for <see cref="T:Castle.ActiveRecord.Framework.INHContributor"/> which applies
            to all root types by default.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.INHContributor">
            <summary>
            <para>
            Contributors are an extension point of ActiveRecord. Instances of INHContributor
            are registered at <see cref="T:Castle.ActiveRecord.ActiveRecordStarter"/> before the framework is
            initialized. They are called before the session factory is created and can therefore
            contribute to NHibernate's configuration of the session factory.
            </para>
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.INHContributor.Contribute(NHibernate.Cfg.Configuration)">
            <summary>
            Called to modify the configuration before the session factory is called.
            </summary>
            <remarks>
            The order in which multiple contributors are called is not determined. The method
            must not assume any fixed order and must therefore not be used to counter 
            modifications by other contributors. 
            </remarks>
            <param name="configuration">The NH configuration to modify.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.INHContributor.AppliesToRootType">
            <summary>
            This predicate can be set per instance and will be called by the framework to
            determine whether the contributor should add to the actual root type.
            </summary>
            <example><![CDATA[
            public class SampleContributor : INHContributor
            {
            	public Predicate<Type> AppliesToRootType
            	{
            		get { return _appliesToRootType; }
            		set { _appliesToRootType = value; }
            	}
            	
            	// Applies to default root type only by default
            	private Predicate<Type>_appliesToRootType = ( (type) => type.Equals(typeof(ActiveRecordBase)));
            	
            	public void Contribute(Configuration c) {}
            }
            ]]></example>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.AbstractNHContributor.Contribute(NHibernate.Cfg.Configuration)">
            <summary>
            The actual contribution method.
            </summary>
            <param name="configuration">The configuration to be modified.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.AbstractNHContributor.AppliesToRootType">
            <summary>
            Implements <see cref="P:Castle.ActiveRecord.Framework.INHContributor.AppliesToRootType"/>
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerContributor.Add(Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerConfig)">
            <summary>
            Adds an event listener configuration
            </summary>
            <param name="config">the configuration to add</param>
            <returns>the added configuration</returns>
            <exception cref="T:System.ArgumentNullException">When the configuration is null</exception>
            <exception cref="T:System.ArgumentException">When the configuration is already present.</exception>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerContributor.Get(System.Type)">
            <summary>
            Returns the listener config for a specified listener type.
            </summary>
            <param name="listenerType">the type to look for</param>
            <returns>the listener config or null if it does not exist</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerContributor.Remove(System.Type)">
            <summary>
            Gets and removes the configuration for the type.
            </summary>
            <param name="listenerType">the type to look for</param>
            <returns>the configuration for the type</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerContributor.Contribute(NHibernate.Cfg.Configuration)">
            <summary>
            Configures the configuration with the registered listeners according the config
            </summary>
            <param name="configuration">the configuration object to add the listeners to</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.EventListener.EventListenerContributor.#ctor">
            <summary>
            Creates a listener
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel">
            <summary>
            This model of a full Active Record persistent class.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.IVisitable">
            <summary>
            For implementing the Visitor pattern.
            All the nodes in the model implements this interface
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitable.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.type2Model">
            <summary>
            The mapping between a type and a model
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.isDebug">
            <summary>
            Whatever Active Record will generate debug information or not
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.isLazyByDefault">
            <summary>
            Whatever types that does not explicitly state that they are lazy should be lazy.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.pluralizeTableNames">
            <summary>
            Whether the default inferred table name is plural
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel"/> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Register(System.Type,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Used internally register an association between a type and its model
            </summary>
            <param name="arType"></param>
            <param name="model"></param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.GetModel(System.Type)">
            <summary>
            Gets the <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel"/> for a given ActiveRecord class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.GetModels">
            <summary>
            Gets an array containing the <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel"/> for every registered ActiveRecord class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.GetNonProxy(System.Type)">
            <summary>
            Get the base type is the object is lazy
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Parent">
            <summary>
            Gets or sets the parent model
            </summary>
            <value>The parent.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Type">
            <summary>
            Gets the type for this model
            </summary>
            <value>The type.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.IsJoinedSubClassBase">
            <summary>
            Gets or sets a value indicating whether this instance is joined sub class base.
            </summary>
            <value>
            	<c>true</c> if this instance is joined sub class base; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.IsDiscriminatorBase">
            <summary>
            Gets or sets a value indicating whether this instance is discriminator base.
            </summary>
            <value>
            	<c>true</c> if this instance is discriminator base; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.IsDiscriminatorSubClass">
            <summary>
            Gets or sets a value indicating whether this instance is discriminator sub class.
            </summary>
            <value>
            	<c>true</c> if this instance is discriminator sub class; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.IsJoinedSubClass">
            <summary>
            Gets or sets a value indicating whether this instance is joined sub class.
            </summary>
            <value>
            	<c>true</c> if this instance is joined sub class; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.IsNestedType">
            <summary>
            Gets or sets a value indicating whether this instance is nested type.
            </summary>
            <value>
            	<c>true</c> if this instance is nested type; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.ParentNested">
            <summary>
            Gets or sets the parent nested.
            </summary>
            <value>The parent nested.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.IsNestedCompositeType">
            <summary>
            Gets or sets a value indicating whether this instance is nested type.
            </summary>
            <value>
            	<c>true</c> if this instance is nested type; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.ActiveRecordAtt">
            <summary>
            Gets or sets the active record attribute
            </summary>
            <value>The active record att.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Key">
            <summary>
            Used only by joined subclasses
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Timestamp">
            <summary>
            Gets or sets the timestamp model
            </summary>
            <value>The timestamp.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Version">
            <summary>
            Gets or sets the version model
            </summary>
            <value>The version.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Imports">
            <summary>
            Gets all the imports
            </summary>
            <value>The imports.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Properties">
            <summary>
            Gets all the properties
            </summary>
            <value>The properties.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Fields">
            <summary>
            Gets all the fields
            </summary>
            <value>The fields.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.ComponentParent">
            <summary>
            If the object is a component, will return the objects declared parent property.
            There should only be one, but implemented as a list
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.HasManyToAny">
            <summary>
            Gets the list of [has many to any] models
            </summary>
            <value>The has many to any.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Anys">
            <summary>
            Gets the list of [any] model
            </summary>
            <value>The anys.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Classes">
            <summary>
            Gets the list of the derived classes
            </summary>
            <value>The classes.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.JoinedClasses">
            <summary>
            Gets the list of derived joined classes.
            </summary>
            <value>The joined classes.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.JoinedTables">
            <summary>
            Gets the list of joined tables.
            </summary>
            <value>The joined tables.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Components">
            <summary>
            Gets the list of components.
            </summary>
            <value>The components.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.BelongsTo">
            <summary>
            Gets the list of [belongs to] models
            </summary>
            <value>The belongs to.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.HasMany">
            <summary>
            Gets the list of [has many] models
            </summary>
            <value>The has many.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.HasAndBelongsToMany">
            <summary>
            Gets the list of [has and belongs to many] models
            </summary>
            <value>The has and belongs to many.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.OneToOnes">
            <summary>
            Gets the list of [one to one] models
            </summary>
            <value>The one to ones.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.CollectionIDs">
            <summary>
            Gets the list of [collection id] models
            </summary>
            <value>The collection I ds.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.PrimaryKey">
            <summary>
            For unique Primary keys
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.CompositeKey">
            <summary>
            For Composite Primary keys
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Hilos">
            <summary>
            Gets the list of [hilo] models
            </summary>
            <value>The hilos.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.NotMappedProperties">
            <summary>
            Gets the list of  properties not mapped .
            </summary>
            <value>The not mapped properties.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.Validators">
            <summary>
            Gets the validators.
            </summary>
            <value>The validators.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.UseAutoImport">
            <summary>
            Gets a value indicating whether to use auto import
            </summary>
            <value><c>true</c> if should use auto import; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.CompositeUserType">
            <summary>
            Gets the composite user types properties.
            </summary>
            <value>The type of the composite user.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.ExtendedProperties">
            <summary>
            Gets the extended properties. Used to store/retrieve information collected by model builder extensions.
            <seealso cref="T:Castle.ActiveRecord.Framework.Internal.IModelBuilderExtension"/>
            </summary>
            <value>The extended properties.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.PropertyDictionary">
            <summary>
            Gets the property dictionary. Used to provide fast access 
            to a <see cref="T:Castle.ActiveRecord.Framework.Internal.PropertyModel"/> based on the property name.
            </summary>
            <value>The property dictionary.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.BelongsToDictionary">
            <summary>
            Gets the belongs to dictionary. Used to provide fast access 
            to a <see cref="T:Castle.ActiveRecord.Framework.Internal.BelongsToModel"/> based on the property name.
            </summary>
            <value>The belongs to dictionary.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.HasManyToAnyDictionary">
            <summary>
            Gets the has many to any dictionary. Used to provide fast access 
            to a <see cref="T:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel"/> based on the property name.
            </summary>
            <value>The has many to any dictionary.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.HasManyDictionary">
            <summary>
            Gets the has many dictionary. Used to provide fast access 
            to a <see cref="T:Castle.ActiveRecord.Framework.Internal.HasManyModel"/> based on the property name.
            </summary>
            <value>The has many dictionary.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel.HasAndBelongsToManyDictionary">
            <summary>
            Gets the has and belongs to many dictionary. Used to provide fast access 
            to a <see cref="T:Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel"/> based on the property name.
            </summary>
            <value>The has and belongs to many dictionary.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.AnyModel">
            <summary>
            Model for [Any] association, a polymorphic association without common base class
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AnyModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.AnyAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.AnyModel"/> class.
            </summary>
            <param name="prop">The prop.</param>
            <param name="anyAtt">Any att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AnyModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.AnyModel.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.AnyModel.AnyAtt">
            <summary>
            Gets the [Any] attribute
            </summary>
            <value>Any att.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.AnyModel.MetaValues">
            <summary>
            Gets or sets the meta values.
            </summary>
            <value>The meta values.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.BelongsToModel">
            <summary>
            Model for BelongTo - A many to one assoication between persistent entities.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.BelongsToModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.BelongsToAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.BelongsToModel"/> class.
            </summary>
            <param name="propInfo">The prop info.</param>
            <param name="belongsToAtt">The belongs to att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.BelongsToModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.BelongsToModel.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.BelongsToModel.BelongsToAtt">
            <summary>
            Gets the belongs to attribute
            </summary>
            <value>The belongs to att.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.CollectionIDModel">
            <summary>
            This is used in IdBag scenario to specify to collection id.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.CollectionIDModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.CollectionIDAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.CollectionIDModel"/> class.
            </summary>
            <param name="propInfo">The prop info.</param>
            <param name="collAtt">The coll att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.CollectionIDModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.CollectionIDModel.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.CollectionIDModel.CollectionIDAtt">
            <summary>
            Gets the collection ID att.
            </summary>
            <value>The collection ID att.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.CollectionIDModel.Hilo">
            <summary>
            Gets or sets the hilo.
            </summary>
            <value>The hilo.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.CompositeKeyModel">
            <summary>
            Model for representing a composite key
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.CompositeKeyModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.CompositeKeyAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.CompositeKeyModel"/> class.
            </summary>
            <param name="propInfo">The prop info.</param>
            <param name="pkAtt">The pk att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.CompositeKeyModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.CompositeKeyModel.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.CompositeKeyModel.CompositeKeyAtt">
            <summary>
            Gets the composite key att.
            </summary>
            <value>The composite key att.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel">
            <summary>
            Model for representing a Composite User type map.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel.#ctor(System.Reflection.MemberInfo,System.Type,Castle.ActiveRecord.CompositeUserTypeAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel"/> class.
            </summary>
            <param name="member">The member marked with the attribute.</param>
            <param name="memberType">The type of member marked with the attribute.</param>
            <param name="attribute">The metadata attribute.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel.Member">
            <summary>
            Gets the member marked with the attribute.
            </summary>
            <value>The member.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel.MemberType">
            <summary>
            Gets the type of member marked with the attribute.
            </summary>
            <value>The member.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel.Attribute">
            <summary>
            Gets the attribute instance.
            </summary>
            <value>The attribute.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.DependentObjectModel">
            <summary>
             This model is used to represent a dependent object value type (&lt;composite-element/&gt; - in NHibernate talk).
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.DependentObjectModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.HasManyAttribute,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
             Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.DependentObjectModel"/> class.
            </summary>
             <param name="propInfo">The prop info.</param>
             <param name="hasManyAtt">The nested att.</param>
             <param name="dependentObjectModel">The nested model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.DependentObjectModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.DependentObjectModel.Model">
            <summary>
            Gets the model.
            </summary>
            <value>The model.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.DependentObjectModel.HasManyAtt">
            <summary>
            Gets the has many attribute
            </summary>
            <value>The has many att.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.FieldModel">
            <summary>
            Model for a persitent property that uses a field to get/set the values.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.FieldModel.#ctor(System.Reflection.FieldInfo,Castle.ActiveRecord.FieldAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.FieldModel"/> class.
            </summary>
            <param name="field">The field.</param>
            <param name="att">The att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.FieldModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.FieldModel.Field">
            <summary>
            Gets the field.
            </summary>
            <value>The field.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.FieldModel.FieldAtt">
            <summary>
            Gets the field attribute
            </summary>
            <value>The field att.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel">
            <summary>
            Model to HasAndBelongsToMany, which is used to model a many to many assoication.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.HasAndBelongsToManyAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel"/> class.
            </summary>
            <param name="propInfo">The prop info.</param>
            <param name="hasManyAtt">The has many att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel.HasManyAtt">
            <summary>
            Gets the has many attribute
            </summary>
            <value>The has many att.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel.CollectionID">
            <summary>
            Gets or sets the collection ID.
            </summary>
            <value>The collection ID.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.HasManyModel">
            <summary>
            Model to represent a HasMany ( one to many ) association
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.HasManyModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.HasManyAttribute,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.HasManyModel"/> class.
            </summary>
            <param name="propInfo">The prop info.</param>
            <param name="hasManyAtt">The has many att.</param>
            <param name="containingTypeModel">The model for the type that contains the HasMany reference.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.HasManyModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyModel.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyModel.HasManyAtt">
            <summary>
            Gets the has many attribute
            </summary>
            <value>The has many att.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyModel.ContainingTypeModel">
            <summary>
            This is a reference to the model (the ActiveRecord type) that defined the HasMany relationship.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyModel.DependentObjectModel">
            <summary>
            Gets/Sets the the dependent object model
            </summary>
            <value>The dependent object model.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel">
            <summary>
            This model represent a &lt;many-to-any/&gt; polymorphic association
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.HasManyToAnyAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel"/> class.
            </summary>
            <param name="prop">The prop.</param>
            <param name="hasManyToAnyAtt">The has many to any att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.HasManyToAnyAtt">
            <summary>
            Gets the has many to any attribute
            </summary>
            <value>The has many to any att.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Configuration">
            <summary>
            Gets the configuration.
            </summary>
            <value>The configuration.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.MetaValues">
            <summary>
            Gets or sets the meta values.
            </summary>
            <value>The meta values.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config">
            <summary>
            I need this class to pass special configuration for the many-to-any
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config.#ctor(Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config"/> class.
            </summary>
            <param name="parent">The parent.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config.Parent">
            <summary>
            Gets or sets the parent model
            </summary>
            <value>The parent.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.HiloModel">
            <summary>
            Model for HiLo algorithm used to generate primary key values
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.HiloModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.HiloAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.HiloModel"/> class.
            </summary>
            <param name="propInfo">The prop info.</param>
            <param name="hiloAtt">The hilo att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.HiloModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.HiloModel.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.HiloModel.HiloAtt">
            <summary>
            Gets the hilo attribute
            </summary>
            <value>The hilo att.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.ImportModel">
            <summary>
            Model for importing classes so HQL queries can use them more easily.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ImportModel.#ctor(Castle.ActiveRecord.ImportAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.ImportModel"/> class.
            </summary>
            <param name="att">The att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ImportModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ImportModel.ImportAtt">
            <summary>
            Gets the import attribute
            </summary>
            <value>The import att.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.JoinedTableModel">
            <summary>
            Model for joining an additional table to Active Record class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.JoinedTableModel.#ctor(Castle.ActiveRecord.JoinedTableAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.JoinedTableModel"/> class.
            </summary>
            <param name="att">The att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.JoinedTableModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.JoinedTableModel.JoinedTableAttribute">
            <summary>
            Gets the joined table attribute
            </summary>
            <value>The joined table att.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.JoinedTableModel.Properties">
            <summary>
            Gets all the properties
            </summary>
            <value>The properties.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.JoinedTableModel.Fields">
            <summary>
            Gets all the fields
            </summary>
            <value>The fields.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.JoinedTableModel.Components">
            <summary>
            Gets the list of components.
            </summary>
            <value>The components.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.JoinedTableModel.BelongsTo">
            <summary>
            Gets the list of [belongs to] models
            </summary>
            <value>The belongs to.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.JoinedTableModel.Anys">
            <summary>
            Gets the list of [any] model
            </summary>
            <value>The anys.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.KeyModel">
            <summary>
            Model for a joined key property in a joined subclass
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.KeyModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.JoinedKeyAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.KeyModel"/> class.
            </summary>
            <param name="propInfo">The prop info.</param>
            <param name="att">The att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.KeyModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.KeyModel.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.KeyModel.JoinedKeyAtt">
            <summary>
            Gets the joined key attribute
            </summary>
            <value>The joined key att.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.NestedModel">
            <summary>
            This model is used to represent a nested value type (&lt;component/&gt; - in NHibernate talk).
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.NestedModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.NestedAttribute,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.NestedModel"/> class.
            </summary>
            <param name="propInfo">The prop info.</param>
            <param name="nestedAtt">The nested att.</param>
            <param name="nestedModel">The nested model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.NestedModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.NestedModel.Model">
            <summary>
            Gets the model.
            </summary>
            <value>The model.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.NestedModel.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.NestedModel.NestedAtt">
            <summary>
            Gets the nested attribute
            </summary>
            <value>The nested att.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel">
            <summary>
            This model is used to represent a nested value type's parent (&lt;parent /&gt; - in NHibernate talk).
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.NestedParentReferenceAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel"/> class.
            </summary>
            <param name="propInfo">The prop info.</param>
            <param name="nestedParentAtt">The parent att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel.NestedParentAtt">
            <summary>
            Gets the nested attribute
            </summary>
            <value>The nested att.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.OneToOneModel">
            <summary>
            Model One To One assoication
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.OneToOneModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.OneToOneAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.OneToOneModel"/> class.
            </summary>
            <param name="propInfo">The prop info.</param>
            <param name="att">The att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.OneToOneModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.OneToOneModel.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.OneToOneModel.OneToOneAtt">
            <summary>
            Gets the one to one attribute
            </summary>
            <value>The one to one att.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel">
            <summary>
            Model for a Primary Key
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.PrimaryKeyAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel"/> class.
            </summary>
            <param name="propInfo">The prop info.</param>
            <param name="pkAtt">The pk att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel.PrimaryKeyAtt">
            <summary>
            Gets the primary key attribute
            </summary>
            <value>The primary key att.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.PropertyModel">
            <summary>
            Model for a simple persistent property
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.PropertyModel.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.PropertyModel"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.PropertyModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.PropertyAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.PropertyModel"/> class.
            </summary>
            <param name="prop">The prop.</param>
            <param name="att">The att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.PropertyModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.PropertyModel.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.PropertyModel.PropertyAtt">
            <summary>
            Gets the property attribute
            </summary>
            <value>The property att.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.TimestampModel">
            <summary>
            Model for [Timestamp] properties
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.TimestampModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.TimestampAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.TimestampModel"/> class.
            </summary>
            <param name="prop">The prop.</param>
            <param name="att">The att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.TimestampModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.TimestampModel.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.TimestampModel.TimestampAtt">
            <summary>
            Gets the timestamp attribute
            </summary>
            <value>The timestamp att.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.VersionModel">
            <summary>
            Model for version property on an entity
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.VersionModel.#ctor(System.Reflection.PropertyInfo,Castle.ActiveRecord.VersionAttribute)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.VersionModel"/> class.
            </summary>
            <param name="prop">The prop.</param>
            <param name="att">The att.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.VersionModel.Accept(Castle.ActiveRecord.Framework.Internal.IVisitor)">
            <summary>
            Accepts the specified visitor and call the relevant IVisitor.Visit***() method
            </summary>
            <param name="visitor">The visitor.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.VersionModel.Property">
            <summary>
            Gets the property.
            </summary>
            <value>The property.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.VersionModel.VersionAtt">
            <summary>
            Gets the version attribute
            </summary>
            <value>The version att.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor">
            <summary>
            Base class for visitors that needs to traverse the entire Active Record Model
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.IVisitor">
            <summary>
            For implementign the visitor pattern.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitModel(Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Visits the top level of the model.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitPrimaryKey(Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel)">
            <summary>
            Visits the primary key.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitCompositePrimaryKey(Castle.ActiveRecord.Framework.Internal.CompositeKeyModel)">
            <summary>
            Visits the composite primary key.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitHasManyToAny(Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel)">
            <summary>
            Visits the has many to any association
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitAny(Castle.ActiveRecord.Framework.Internal.AnyModel)">
            <summary>
            Visits any.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitProperty(Castle.ActiveRecord.Framework.Internal.PropertyModel)">
            <summary>
            Visits the property.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitField(Castle.ActiveRecord.Framework.Internal.FieldModel)">
            <summary>
            Visits the field.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitNestedParentReference(Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel)">
            <summary>
            Visits the component parent reference
            </summary>
            <param name="referenceModel">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitVersion(Castle.ActiveRecord.Framework.Internal.VersionModel)">
            <summary>
            Visits the version.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitTimestamp(Castle.ActiveRecord.Framework.Internal.TimestampModel)">
            <summary>
            Visits the timestamp.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitKey(Castle.ActiveRecord.Framework.Internal.KeyModel)">
            <summary>
            Visits the key.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitBelongsTo(Castle.ActiveRecord.Framework.Internal.BelongsToModel)">
            <summary>
            Visits the belongs to association
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitHasMany(Castle.ActiveRecord.Framework.Internal.HasManyModel)">
            <summary>
            Visits the has many association
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitOneToOne(Castle.ActiveRecord.Framework.Internal.OneToOneModel)">
            <summary>
            Visits the one to one association
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitHasAndBelongsToMany(Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel)">
            <summary>
            Visits the has and belongs to many association
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitHilo(Castle.ActiveRecord.Framework.Internal.HiloModel)">
            <summary>
            Visits the hilo strategy
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitNested(Castle.ActiveRecord.Framework.Internal.NestedModel)">
            <summary>
            Visits the nested (component) model
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitCollectionID(Castle.ActiveRecord.Framework.Internal.CollectionIDModel)">
            <summary>
            Visits the collection ID.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitHasManyToAnyConfig(Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config)">
            <summary>
            Visits the has many to any configuration
            </summary>
            <param name="hasManyToAnyConfigModel">The has many to any config model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitImport(Castle.ActiveRecord.Framework.Internal.ImportModel)">
            <summary>
            Visits the import statement
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitDependentObject(Castle.ActiveRecord.Framework.Internal.DependentObjectModel)">
            <summary>
            Visits the dependent object model
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitCompositeUserType(Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel)">
            <summary>
            Visits the custom composite user type.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IVisitor.VisitJoinedTable(Castle.ActiveRecord.Framework.Internal.JoinedTableModel)">
            <summary>
            Visits the joined table configuration.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitNode(Castle.ActiveRecord.Framework.Internal.IVisitable)">
            <summary>
            Visits the node.
            </summary>
            <param name="visitable">The visitable.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitNodes(System.Collections.IEnumerable)">
            <summary>
            Visits the nodes.
            </summary>
            <param name="nodes">The nodes.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitModel(Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Visits the model.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitPrimaryKey(Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel)">
            <summary>
            Visits the primary key.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitCompositePrimaryKey(Castle.ActiveRecord.Framework.Internal.CompositeKeyModel)">
            <summary>
            Visits the composite primary key.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitHasManyToAny(Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel)">
            <summary>
            Visits the has many to any.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitProperty(Castle.ActiveRecord.Framework.Internal.PropertyModel)">
            <summary>
            Visits the property.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitField(Castle.ActiveRecord.Framework.Internal.FieldModel)">
            <summary>
            Visits the field.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitNestedParentReference(Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel)">
            <summary>
            Visits the component parent
            </summary>
            <param name="referenceModel">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitAny(Castle.ActiveRecord.Framework.Internal.AnyModel)">
            <summary>
            Visits any.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitVersion(Castle.ActiveRecord.Framework.Internal.VersionModel)">
            <summary>
            Visits the version.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitTimestamp(Castle.ActiveRecord.Framework.Internal.TimestampModel)">
            <summary>
            Visits the timestamp.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitKey(Castle.ActiveRecord.Framework.Internal.KeyModel)">
            <summary>
            Visits the key.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitBelongsTo(Castle.ActiveRecord.Framework.Internal.BelongsToModel)">
            <summary>
            Visits the belongs to.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitHasMany(Castle.ActiveRecord.Framework.Internal.HasManyModel)">
            <summary>
            Visits the has many.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitOneToOne(Castle.ActiveRecord.Framework.Internal.OneToOneModel)">
            <summary>
            Visits the one to one.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitHasAndBelongsToMany(Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel)">
            <summary>
            Visits the has and belongs to many.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitHilo(Castle.ActiveRecord.Framework.Internal.HiloModel)">
            <summary>
            Visits the hilo.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitNested(Castle.ActiveRecord.Framework.Internal.NestedModel)">
            <summary>
            Visits the nested.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitCollectionID(Castle.ActiveRecord.Framework.Internal.CollectionIDModel)">
            <summary>
            Visits the collection ID.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitHasManyToAnyConfig(Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config)">
            <summary>
            Visits the has many to any config.
            </summary>
            <param name="hasManyToAnyConfigModel">The has many to any config model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitImport(Castle.ActiveRecord.Framework.Internal.ImportModel)">
            <summary>
            Visits the import.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitDependentObject(Castle.ActiveRecord.Framework.Internal.DependentObjectModel)">
            <summary>
            Visits the Dependent Object 
            </summary>
            <param name="model">The model</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitCompositeUserType(Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel)">
            <summary>
            Visits the custom composite user type.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.VisitJoinedTable(Castle.ActiveRecord.Framework.Internal.JoinedTableModel)">
            <summary>
            Visits the joined table configuration.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AbstractDepthFirstVisitor.GuessType(System.Type,System.Type)">
            <summary>
            Guesses the type of the other end.
            </summary>
            <param name="type">The type.</param>
            <param name="propertyType">Type of the property.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.GraphConnectorVisitor">
            <summary>
            Connects <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel"/> with their parents 
            <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel"/>
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.GraphConnectorVisitor.#ctor(Castle.ActiveRecord.Framework.Internal.ActiveRecordModelCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.GraphConnectorVisitor"/> class.
            </summary>
            <param name="arCollection">The ar collection.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.GraphConnectorVisitor.VisitModel(Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Visits the model.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.GraphConnectorVisitor.VisitNested(Castle.ActiveRecord.Framework.Internal.NestedModel)">
            <summary>
            Visits the nested.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.GraphConnectorVisitor.VisitCollectionID(Castle.ActiveRecord.Framework.Internal.CollectionIDModel)">
            <summary>
            Visits the collection ID.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.GraphConnectorVisitor.VisitHilo(Castle.ActiveRecord.Framework.Internal.HiloModel)">
            <summary>
            Visits the hilo model
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor">
            <summary>
            Traverse the tree checking the semantics of the relation and
            association. The goal is to raise clear exceptions with tips of how 
            to fix any error.
            It also tries to infer as much information from the class / attribute model as possible so it can
            complete the missing information without the user needing to specify it.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.#ctor(Castle.ActiveRecord.Framework.Internal.ActiveRecordModelCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor"/> class.
            </summary>
            <param name="arCollection">The ar collection.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitModel(Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Visits the model.
            </summary>
            <remarks>
            Check that the model:
             - Define only a discriminator or a join subclass, not both
             - Doesn't specify version/timestamp property on a joined subclass / discriminator subclass
             - Validate that the custom entity persister implements IEntityPersister
             - Validate the joined subclasses has a [JoinedKey] to map back to the parent table
             - Validate that the class has a PK
            </remarks>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitPrimaryKey(Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel)">
            <summary>
            Visits the primary key.
            </summary>
            <remarks>
            Infer column name and the reverse property if using [OneToOne]
            </remarks>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitCompositePrimaryKey(Castle.ActiveRecord.Framework.Internal.CompositeKeyModel)">
            <summary>
            Visits the composite primary key.
            </summary>
            <remarks>
            Validate that the composite key type is implementing GetHashCode() and Equals(), is mark serializable.
            Validate that the compose key is compose of two or more columns
            </remarks>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitProperty(Castle.ActiveRecord.Framework.Internal.PropertyModel)">
            <summary>
            Visits the property.
            </summary>
            <remarks>
            Infer column name and whatever this propery can be null or not
            Also catch common mistake of try to use [Property] on an entity, instead of [BelongsTo]
            Ensure that joined properties have a joined table.
            </remarks>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitField(Castle.ActiveRecord.Framework.Internal.FieldModel)">
            <summary>
            Visits the field.
            </summary>
            <remarks>
            Infer column name and nullablity
            </remarks>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitKey(Castle.ActiveRecord.Framework.Internal.KeyModel)">
            <summary>
            Visits the key.
            </summary>
            <remarks>
            Infer column name
            </remarks>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitVersion(Castle.ActiveRecord.Framework.Internal.VersionModel)">
            <summary>
            Visits the version.
            </summary>
            <remarks>
            Infer column name
            </remarks>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitTimestamp(Castle.ActiveRecord.Framework.Internal.TimestampModel)">
            <summary>
            Visits the timestamp.
            </summary>
            <remarks>
            Infer column name
            </remarks>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitBelongsTo(Castle.ActiveRecord.Framework.Internal.BelongsToModel)">
            <summary>
            Visits the belongs to.
            </summary>
            <remarks>
            Infer column name and type
            Verify that the property is virtual if the class was marked lazy.
            </remarks>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitHasManyToAny(Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel)">
            <summary>
            Visit the has many to any
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitAny(Castle.ActiveRecord.Framework.Internal.AnyModel)">
            <summary>
            Visits any.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitHasMany(Castle.ActiveRecord.Framework.Internal.HasManyModel)">
            <summary>
            Visits the has many.
            </summary>
            <remarks>
            Guess the type of the relation, if not specified explicitly
            Verify that the assoication is valid on [HasMany]
            Validate that required information is specified
            Infer the other side of the assoication and grab require data from it
            </remarks>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.GuessElementMappingBasedOnEnum(Castle.ActiveRecord.Framework.Internal.HasManyModel)">
            <summary>
            Guesses the element mapping based on enum.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitHasAndBelongsToMany(Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel)">
            <summary>
            Visits the has and belongs to many.
            </summary>
            <remarks>
            Verify that a link table was specified
            Verify that a key was specified and that it is valid 
            Verify that required information was specified
            </remarks>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitOneToOne(Castle.ActiveRecord.Framework.Internal.OneToOneModel)">
            <summary>
            Visits the one to one.
            </summary>
            <remarks>
            Infer the type on the other side
            </remarks>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitNested(Castle.ActiveRecord.Framework.Internal.NestedModel)">
            <summary>
            Visits the nested model
            </summary>
            <remarks>
            Infer the column name and applies and column prefixes specified
            </remarks>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitCompositeUserType(Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel)">
            <summary>
            Visits the custom composite user type.
            </summary>
            <remarks>
            Apply any column prefixes specified
            </remarks>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.VisitJoinedTable(Castle.ActiveRecord.Framework.Internal.JoinedTableModel)">
            <summary>
            Visits the joined table.
            </summary>
            <remarks>
            Infer column name
            </remarks>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.GetIndexTypeFromDictionary(System.Type)">
            <summary>
            Gets the index type of a mapped dictionary.
            </summary>
            <param name="propertyType">Type of the property.</param>
            <returns>The index type of a map element</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.SemanticVerifierVisitor.GetMapTypeFromDictionary(System.Type)">
            <summary>
            Gets the index type of a mapped dictionary.
            </summary>
            <param name="propertyType">Type of the property.</param>
            <returns>The index type of a map element</returns>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor">
            <summary>
            Traverse the tree emitting proper xml configuration
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.Reset">
            <summary>
            Resets this instance.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.CreateXml(Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Creates the XML.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitModel(Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Visits the model.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitPrimaryKey(Castle.ActiveRecord.Framework.Internal.PrimaryKeyModel)">
            <summary>
            Visits the primary key.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitCompositePrimaryKey(Castle.ActiveRecord.Framework.Internal.CompositeKeyModel)">
            <summary>
            Visits the composite primary key.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitImport(Castle.ActiveRecord.Framework.Internal.ImportModel)">
            <summary>
            Visits the import.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitProperty(Castle.ActiveRecord.Framework.Internal.PropertyModel)">
            <summary>
            Visits the property.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitJoinedTable(Castle.ActiveRecord.Framework.Internal.JoinedTableModel)">
            <summary>
            Visits the joined table.
            </summary>
            <remarks>
            Infer column name
            </remarks>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitField(Castle.ActiveRecord.Framework.Internal.FieldModel)">
            <summary>
            Visits the field.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitNestedParentReference(Castle.ActiveRecord.Framework.Internal.NestedParentReferenceModel)">
            <summary>
            Visits the parent
            </summary>
            <param name="referenceModel">The reference model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitAny(Castle.ActiveRecord.Framework.Internal.AnyModel)">
            <summary>
            Visits any.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitHasManyToAny(Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel)">
            <summary>
            Visits the has many to any.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitHasManyToAnyConfig(Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel.Config)">
            <summary>
            Visits the has many to any config.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitVersion(Castle.ActiveRecord.Framework.Internal.VersionModel)">
            <summary>
            Visits the version.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitTimestamp(Castle.ActiveRecord.Framework.Internal.TimestampModel)">
            <summary>
            Visits the timestamp.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitKey(Castle.ActiveRecord.Framework.Internal.KeyModel)">
            <summary>
            Visits the key.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitOneToOne(Castle.ActiveRecord.Framework.Internal.OneToOneModel)">
            <summary>
            Visits the one to one.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitBelongsTo(Castle.ActiveRecord.Framework.Internal.BelongsToModel)">
            <summary>
            Visits the belongs to.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitHasMany(Castle.ActiveRecord.Framework.Internal.HasManyModel)">
            <summary>
            Visits the has many.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitHasAndBelongsToMany(Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel)">
            <summary>
            Visits the has and belongs to many.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitNested(Castle.ActiveRecord.Framework.Internal.NestedModel)">
            <summary>
            Visits the nested.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitDependentObject(Castle.ActiveRecord.Framework.Internal.DependentObjectModel)">
            <summary>
            Visits the dependent object.
            </summary>
            <param name="model">The model</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitCollectionID(Castle.ActiveRecord.Framework.Internal.CollectionIDModel)">
            <summary>
            Visits the collection ID.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitHilo(Castle.ActiveRecord.Framework.Internal.HiloModel)">
            <summary>
            Visits the hilo.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.VisitCompositeUserType(Castle.ActiveRecord.Framework.Internal.CompositeUserTypeModel)">
            <summary>
            Visits the custom composite user type.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.MakeTypeName(System.Type)">
            <summary>
            Create a valid name from a type, without including all the version and public key
            information
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.XmlGenerationVisitor.Xml">
            <summary>
            Gets the XML.
            </summary>
            <value>The XML.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelBuilder">
            <summary>
            Bulids an <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel"/> from a type and does some inital validation.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelBuilder.Create(System.Type)">
            <summary>
            Creates a <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel"/> from the specified type.
            </summary>
            <param name="type">The type.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelBuilder.CreateDummyModelFor(System.Type)">
            <summary>
            Creates the dummy model for the specified type.
            This is required for integration with plain NHibernate entities
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelBuilder.SetExtension(Castle.ActiveRecord.Framework.Internal.IModelBuilderExtension)">
            <summary>
            Sets the extension.
            </summary>
            <param name="extension">The extension.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelBuilder.PopulateModel(Castle.ActiveRecord.Framework.Internal.ActiveRecordModel,System.Type)">
            <summary>
            Populates the model from tye type
            </summary>
            <param name="model">The model.</param>
            <param name="type">The type.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelBuilder.GetSafeName(System.String)">
            <summary>
            Remove the generic part from the type name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelBuilder.Models">
            <summary>
            Gets the models.
            </summary>
            <value>The models.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelBuilder.ValidatorRegistry">
            <summary>
            Gets the validator registry used to create the validators
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelCollection">
            <summary>
            Map System.Type to their ActiveRecordModel
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelCollection.Add(Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Adds the specified model.
            </summary>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelCollection.Contains(System.Type)">
            <summary>
            Determines whether the collection contains the specified type.
            </summary>
            <param name="type">The type.</param>
            <returns>
            	<c>true</c> if the collection contains the specified type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Internal.ActiveRecordModelCollection.Item(System.Type)">
            <summary>
            Gets the <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel"/> with the specified type.
            </summary>
            <value></value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.AssemblyXmlGenerator">
            <summary>
            Generate xml from assembly level attributes.
            This is useful if we need to have type-less configuration, such as imports, named queries, etc.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AssemblyXmlGenerator.#ctor">
            <summary>
            Create a new instnace
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AssemblyXmlGenerator.Reset">
            <summary>
            Reset this generator and prepare to generate xml from new assembly.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.AssemblyXmlGenerator.CreateXmlConfigurations(System.Reflection.Assembly)">
            <summary>
            Generate XML from assembly attributes.
            If it can't find relevant attributes, returns null.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.IModelBuilderExtension">
            <summary>
            Gives a chance to external frameworks to plug into 
            the AR model builder process. Particularly useful to 
            inspect attributes and conventions outside the AR domain.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IModelBuilderExtension.ProcessClass(System.Type,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Gives implementors a chance to process the class.
            </summary>
            <param name="type">The type.</param>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IModelBuilderExtension.ProcessProperty(System.Reflection.PropertyInfo,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Gives implementors a chance to process the property.
            </summary>
            <param name="pi">The property info reflection object.</param>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IModelBuilderExtension.ProcessField(System.Reflection.FieldInfo,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Gives implementors a chance to process the field.
            </summary>
            <param name="fi">The field info reflection object.</param>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IModelBuilderExtension.ProcessBelongsTo(System.Reflection.PropertyInfo,Castle.ActiveRecord.Framework.Internal.BelongsToModel,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Gives implementors a chance to process the BelongsTo.
            </summary>
            <param name="pi">The property info reflection object.</param>
            <param name="belongsToModel">The belongs to model.</param>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IModelBuilderExtension.ProcessHasMany(System.Reflection.PropertyInfo,Castle.ActiveRecord.Framework.Internal.HasManyModel,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Gives implementors a chance to process the HasMany.
            </summary>
            <param name="pi">The property info reflection object.</param>
            <param name="hasManyModel">The has many model.</param>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IModelBuilderExtension.ProcessHasManyToAny(System.Reflection.PropertyInfo,Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Gives implementors a chance to process the HasManyToAny.
            </summary>
            <param name="pi">The property info reflection object.</param>
            <param name="hasManyModel">The has many model.</param>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.IModelBuilderExtension.ProcessHasAndBelongsToMany(System.Reflection.PropertyInfo,Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Gives implementors a chance to process the HasAndBelongsToMany.
            </summary>
            <param name="pi">The property info reflection object.</param>
            <param name="hasAndBelongManyModel">The has and belong many model.</param>
            <param name="model">The model.</param>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.Inflector">
            <summary>
            The Inflector class transforms words from one 
            form to another. For example, from singular to plural.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.Inflector.Pluralize(System.String)">
            <summary>
            Return the plural of a word.
            </summary>
            <param name="word">The singular form</param>
            <returns>The plural form of <paramref name="word"/></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.Inflector.Singularize(System.String)">
            <summary>
            Return the singular of a word.
            </summary>
            <param name="word">The plural form</param>
            <returns>The singular form of <paramref name="word"/></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.Inflector.Capitalize(System.String)">
            <summary>
            Capitalizes a word.
            </summary>
            <param name="word">The word to be capitalized.</param>
            <returns><paramref name="word"/> capitalized.</returns>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.ModelBuilderExtensionComposite">
            <summary>
            Dispatches the extension invocations to the inner extension list.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ModelBuilderExtensionComposite.#ctor(System.Collections.Generic.IList{Castle.ActiveRecord.Framework.Internal.IModelBuilderExtension})">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.ModelBuilderExtensionComposite"/> class.
            </summary>
            <param name="extensions">The extensions.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ModelBuilderExtensionComposite.ProcessClass(System.Type,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Dispatches the call to the extensions.
            </summary>
            <param name="type">The type.</param>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ModelBuilderExtensionComposite.ProcessProperty(System.Reflection.PropertyInfo,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Dispatches the call to the extensions.
            </summary>
            <param name="pi">The property info reflection object.</param>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ModelBuilderExtensionComposite.ProcessField(System.Reflection.FieldInfo,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Dispatches the call to the extensions.
            </summary>
            <param name="fi">The field info reflection object.</param>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ModelBuilderExtensionComposite.ProcessBelongsTo(System.Reflection.PropertyInfo,Castle.ActiveRecord.Framework.Internal.BelongsToModel,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Dispatches the call to the extensions.
            </summary>
            <param name="pi">The property info reflection object.</param>
            <param name="belongsToModel">The belongs to model.</param>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ModelBuilderExtensionComposite.ProcessHasMany(System.Reflection.PropertyInfo,Castle.ActiveRecord.Framework.Internal.HasManyModel,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Dispatches the call to the extensions.
            </summary>
            <param name="pi">The property info reflection object.</param>
            <param name="hasManyModel">The has many model.</param>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ModelBuilderExtensionComposite.ProcessHasManyToAny(System.Reflection.PropertyInfo,Castle.ActiveRecord.Framework.Internal.HasManyToAnyModel,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Dispatches the call to the extensions.
            </summary>
            <param name="pi">The property info reflection object.</param>
            <param name="hasManyModel">The has many model.</param>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ModelBuilderExtensionComposite.ProcessHasAndBelongsToMany(System.Reflection.PropertyInfo,Castle.ActiveRecord.Framework.Internal.HasAndBelongsToManyModel,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Dispatches the call to the extensions.
            </summary>
            <param name="pi">The property info reflection object.</param>
            <param name="hasAndBelongManyModel">The has and belong many model.</param>
            <param name="model">The model.</param>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.Modifiers.IQueryModifier">
            <summary>
            Any object which intent to change a NHibernate query must implement
            this interface.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.IQueryModifier.Apply(NHibernate.IQuery)">
            <summary>
            Applies this modifier to the query.
            </summary>
            <param name="query">The query</param>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.Modifiers.QueryParameter">
            <summary>
            Represents a query parameter.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.String,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.QueryParameter"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.QueryParameter"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
            <param name="type">The type.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.Int32,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.QueryParameter"/> class.
            </summary>
            <param name="position">The position.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.Int32,System.Object,NHibernate.Type.IType)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.QueryParameter"/> class.
            </summary>
            <param name="position">The position.</param>
            <param name="value">The value.</param>
            <param name="type">The type.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.String,System.Collections.ICollection,NHibernate.Type.IType)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.QueryParameter"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
            <param name="type">The type.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.String,System.Collections.ICollection)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.QueryParameter"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.Int32,System.Collections.ICollection,NHibernate.Type.IType)">
            <remarks>
            It is important to keep this constructor as is, to avoid
            confusion with the <see cref="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.Int32,System.Object,NHibernate.Type.IType)"/>
            overload.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.Int32,System.Collections.ICollection)">
            <remarks>
            It is important to keep this constructor as is, to avoid
            confusion with the <see cref="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.#ctor(System.Int32,System.Object)"/>
            overload.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.Apply(NHibernate.IQuery)">
            <summary>
            Add this parameter to the <paramref name="query"/>.
            </summary>
            <param name="query">The query</param>
            <remarks>
            Is there a cleaner way to do this, without reflection or complex
            hierarchies?
            </remarks>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.Position">
            <summary>
            The position of the positional parameter, or <c>-1</c>
            if this is a named parameter.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.Name">
            <summary>
            The name of the named parameter, or <c>null</c>
            if this is a positional parameter.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.Value">
            <summary>
            The parameter value.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryParameter.Type">
            <summary>
            The NHibernate type.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.Modifiers.QueryRange">
            <summary>
            Limits a query to the specified results.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryRange.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.QueryRange"/> class.
            </summary>
            <param name="firstResult">The first result.</param>
            <param name="maxResults">The max results.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryRange.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.QueryRange"/> class.
            </summary>
            <param name="maxResults">The max results.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryRange.Apply(NHibernate.IQuery)">
            <summary>
            Applies this modifier to the query.
            </summary>
            <param name="query">The query</param>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryRange.FirstResult">
            <summary>
            Gets the first result.
            </summary>
            <value>The first result.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryRange.MaxResults">
            <summary>
            Gets the max results.
            </summary>
            <value>The max results.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.Modifiers.QueryResultTransformer">
            <summary>
            Defines a query result transformation.
            See <see cref="T:NHibernate.Transform.IResultTransformer"/> for more information.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryResultTransformer.#ctor(NHibernate.Transform.IResultTransformer)">
            <summary>
            Initializes a new instance of the <see cref="P:Castle.ActiveRecord.Queries.Modifiers.QueryResultTransformer.ResultTransformer"/> class.
            </summary>
            <param name="transformer">The result transformer.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.QueryResultTransformer.Castle#ActiveRecord#Queries#Modifiers#IQueryModifier#Apply(NHibernate.IQuery)">
            <summary>
            Applies this modifier to the query.
            </summary>
            <param name="query">The query</param>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.QueryResultTransformer.ResultTransformer">
            <summary>
            Gets the <see cref="T:NHibernate.Transform.IResultTransformer"/>.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.Modifiers.SqlQueryJoinDefinition">
            <summary>
            Represents a SQL query join definition.
            See <see cref="M:NHibernate.ISession.CreateSQLQuery(System.String,System.String[],System.Type[])"/> for more information.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.SqlQueryJoinDefinition.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.SqlQueryJoinDefinition"/> class.
            </summary>
            <param name="associationPath">The association path.</param>
            <param name="associationAlias">The association alias.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.SqlQueryJoinDefinition.Castle#ActiveRecord#Queries#Modifiers#IQueryModifier#Apply(NHibernate.IQuery)">
            <summary>
            Applies this modifier to the query.
            </summary>s
            <param name="query">The query</param>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.SqlQueryJoinDefinition.AssociationPath">
            <summary>
            Gets the path of the assocation
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.SqlQueryJoinDefinition.AssociationAlias">
            <summary>
            Gets the alias for the association
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.Modifiers.SqlQueryReturnDefinition">
            <summary>
            Represents a SQL query return definition.
            See <see cref="M:NHibernate.ISession.CreateSQLQuery(System.String,System.String[],System.Type[])"/> for more information.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.SqlQueryReturnDefinition.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.SqlQueryReturnDefinition"/> class.
            </summary>
            <param name="returnType">Type of the return object.</param>
            <param name="returnAlias">Gets the alias for the object</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.SqlQueryReturnDefinition.Castle#ActiveRecord#Queries#Modifiers#IQueryModifier#Apply(NHibernate.IQuery)">
            <summary>
            Applies this modifier to the query.
            </summary>
            <param name="query">The query</param>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.SqlQueryReturnDefinition.ReturnType">
            <summary>
            Gets the type of the returned object
            </summary>
            <value>The type of the return.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.SqlQueryReturnDefinition.ReturnAlias">
            <summary>
            Gets the alias for the object
            </summary>
            <value>The return alias.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.Modifiers.SqlQueryScalarDefinition">
            <summary>
            Represents a SQL query scalar definition.
            See <see cref="M:NHibernate.ISession.CreateSQLQuery(System.String,System.String[],System.Type[])"/> for more information.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.SqlQueryScalarDefinition.#ctor(NHibernate.Type.IType,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.Modifiers.SqlQueryScalarDefinition"/> class.
            </summary>
            <param name="scalarType">The scalar type.</param>
            <param name="columnAlias">The column alias.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.Modifiers.SqlQueryScalarDefinition.Castle#ActiveRecord#Queries#Modifiers#IQueryModifier#Apply(NHibernate.IQuery)">
            <summary>
            Applies this modifier to the query.
            </summary>s
            <param name="query">The query</param>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.SqlQueryScalarDefinition.ScalarType">
            <summary>
            Gets the scalar type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.Modifiers.SqlQueryScalarDefinition.ColumnAlias">
            <summary>
            Gets the column alias for the scalar
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordBaseQuery">
            <summary>
            Base class for all ActiveRecord queries.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.IActiveRecordQuery">
            <summary>
            Represents an ActiveRecord Query.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.IActiveRecordQuery.Execute(NHibernate.ISession)">
            <summary>
            Executes the specified query and return the results
            </summary>
            <param name="session">The session to execute the query in.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.IActiveRecordQuery.Enumerate(NHibernate.ISession)">
            <summary>
            Enumerates over the result of the query.
            Note: Only use if you expect most of your values to already exist in the second level cache!
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.IActiveRecordQuery.RootType">
            <summary>
            Gets the target type of this query
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.ActiveRecordBaseQuery.queryModifiers">
            <summary>
            list of modifiers for the query
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ActiveRecordBaseQuery"/> class.
            </summary>
            <param name="rootType">The type.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.Castle#ActiveRecord#IActiveRecordQuery#Execute(NHibernate.ISession)">
            <summary>
            Executes the specified query and return the results
            </summary>
            <param name="session">The session to execute the query in.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.Castle#ActiveRecord#IActiveRecordQuery#Enumerate(NHibernate.ISession)">
            <summary>
            Enumerates over the result of the query.
            Note: Only use if you expect most of your values to already exist in the second level cache!
            </summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.InternalExecute(NHibernate.ISession)">
            <summary>
            Simply creates the query and then call its <see cref="M:NHibernate.IQuery.List"/> method.
            </summary>
            <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession"/></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.InternalEnumerate(NHibernate.ISession)">
            <summary>
            Simply creates the query and then call its <see cref="M:NHibernate.IQuery.Enumerable"/> method.
            Note: Only use when you expect most of the results to be in the second level cache
            </summary>
            <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession"/></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.AddQuery(NHibernate.ISession,NHibernate.IMultiQuery)">
            <summary>
            Add this query to a multiquery
            </summary>
            <param name="session">an <c>ISession</c> shared by all queries in the multiquery</param>
            <param name="multiquery">the <c>IMultiQuery</c> that will receive the newly created query</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.CreateQuery(NHibernate.ISession)">
            <summary>
            Creates the <see cref="T:NHibernate.IQuery"/> instance.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.Clone">
            <summary>
            Just a default clone implementation...
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.AddModifier(Castle.ActiveRecord.Queries.Modifiers.IQueryModifier)">
            <summary>
            Adds a query modifier, to be applied with <see cref="M:Castle.ActiveRecord.ActiveRecordBaseQuery.ApplyModifiers(NHibernate.IQuery)"/>.
            </summary>
            <param name="modifier">The modifier</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.ApplyModifiers(NHibernate.IQuery)">
            <summary>
            Applies the modifiers added with <see cref="M:Castle.ActiveRecord.ActiveRecordBaseQuery.AddModifier(Castle.ActiveRecord.Queries.Modifiers.IQueryModifier)"/>.
            </summary>
            <param name="query">The query in which to apply the modifiers</param>
            <remarks>
            This method is not called automatically 
            by <see cref="T:Castle.ActiveRecord.ActiveRecordBaseQuery"/>, but is called from
            <see cref="T:Castle.ActiveRecord.Queries.HqlBasedQuery"/>.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.GetResultsArray(System.Type,System.Collections.IList,System.Boolean)">
            <summary>
            Converts the results stored in an <see cref="T:System.Collections.IList"/> to an
            strongly-typed array.
            </summary>
            <param name="t">The type of the new array</param>
            <param name="list">The source list</param>
            <param name="distinct">If true, only distinct results will be inserted in the array</param>
            <returns>The strongly-typed array</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.GetResultsArray(System.Type,System.Collections.IList,System.Int32,System.Boolean)">
            <summary>
            Converts the results stored in an <see cref="T:System.Collections.IList"/> to an
            strongly-typed array.
            </summary>
            <param name="t">The type of the new array</param>
            <param name="list">The source list</param>
            <param name="entityIndex">
            If the HQL clause selects more than one field, or a join is performed
            without using <c>fetch join</c>, the contents of the result list will
            be of type <c>object[]</c>. Specify which index in this array should be used to
            compose the new result array. Use <c>-1</c> to ignore this parameter.
            </param>
            <param name="distinct">If true, only distinct results will be inserted in the array</param>
            <returns>The strongly-typed array</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBaseQuery.GetModifiers(Castle.ActiveRecord.ActiveRecordBaseQuery)">
            <summary>
            Gets the internal list of modifiers used by the specified query.
            NOT INTENTED FOR NORMAL USE.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordBaseQuery.RootType">
            <summary>
            Gets the target type of this query
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordBaseQuery.Log">
            <summary>
            Use the specified logger to output diagnostic messages.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.ActiveRecordCriteriaQuery">
            <summary>
            Criteria Query
            Note: This query can not be included in a MultiQuery.
            the problem is that NHibernate does not have a real CriteriaQuery class
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.HqlBasedQuery">
            <summary>
            Base class for all HQL or SQL-based queries.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.HqlBasedQuery"/> class.
            </summary>
            <param name="targetType">Type of the target.</param>
            <param name="query">The query.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.#ctor(System.Type,System.String,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.HqlBasedQuery"/> class.
            </summary>
            <param name="targetType">Type of the target.</param>
            <param name="query">The query.</param>
            <param name="positionalParameters">The positional parameters.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.#ctor(System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.HqlBasedQuery"/> class.
            </summary>
            <param name="targetType">Type of the target.</param>
            <param name="queryLanguage">The query language.</param>
            <param name="query">The query.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.#ctor(System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.HqlBasedQuery"/> class.
            </summary>
            <param name="targetType">Type of the target.</param>
            <param name="queryLanguage">The query language.</param>
            <param name="query">The query.</param>
            <param name="positionalParameters">The positional parameters.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.SetParameter(System.String,System.Object)">
            <summary>
            Sets a parameter with the given name.
            </summary>
            <param name="parameterName">Name of the parameter.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.SetParameter(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Sets a parameter with the given name and type
            </summary>
            <param name="parameterName">Name of the parameter.</param>
            <param name="value">The value.</param>
            <param name="type">The type.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.SetParameterList(System.String,System.Collections.ICollection)">
            <summary>
            Sets a parameter with the given name with a list of values
            </summary>
            <param name="parameterName">Name of the parameter.</param>
            <param name="list">The list.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.SetParameterList(System.String,System.Collections.ICollection,NHibernate.Type.IType)">
            <summary>
            Sets a parameter with the given name with a list of values and type
            </summary>
            <param name="parameterName">Name of the parameter.</param>
            <param name="list">The list.</param>
            <param name="type">The type.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.SetQueryRange(System.Int32,System.Int32)">
            <summary>
            Sets the query range (paging)
            </summary>
            <param name="firstResult">The first result.</param>
            <param name="maxResults">The maximum number of results returned (page size)</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.SetQueryRange(System.Int32)">
            <summary>
            Sets the query range (maximum number of items returned)
            </summary>
            <param name="maxResults">The maximum number of results.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.AddSqlReturnDefinition(System.Type,System.String)">
            <summary>
            Adds a SQL query return definition.
            See <see cref="M:NHibernate.ISession.CreateSQLQuery(System.String,System.String[],System.Type[])"/> for more information.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.AddSqlJoinDefinition(System.String,System.String)">
            <summary>
            Adds a SQL query join definition.
            See <see cref="M:NHibernate.ISession.CreateSQLQuery(System.String,System.String[],System.Type[])"/> for more information.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.AddSqlScalarDefinition(NHibernate.Type.IType,System.String)">
            <summary>
            Adds a SQL query scalar definition.
            See <see cref="M:NHibernate.ISession.CreateSQLQuery(System.String,System.String[],System.Type[])"/> for more information.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.SetResultTransformer(NHibernate.Transform.IResultTransformer)">
            <summary>
            Adds a query result transformer.
            See <see cref="T:NHibernate.Transform.IResultTransformer"/> for more information.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.HqlBasedQuery.CreateQuery(NHibernate.ISession)">
            <summary>
            Creates the <see cref="T:NHibernate.IQuery"/> instance.
            </summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.HqlBasedQuery.Query">
            <summary>
            The query text.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ActiveRecordCriteriaQuery.#ctor(System.Type,NHibernate.Criterion.ICriterion[])">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ActiveRecordCriteriaQuery"/> class.
            </summary>
            <param name="targetType">The target type.</param>
            <param name="criterias">Criteria applied to the query</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ActiveRecordCriteriaQuery.#ctor(System.Type,NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ActiveRecordCriteriaQuery"/> class.
            </summary>
            <param name="targetType">The target type.</param>
            <param name="detachedCriteria">Criteria applied to the query</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ActiveRecordCriteriaQuery.InternalExecute(NHibernate.ISession)">
            <summary>
            Executes the query.
            </summary>
            <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession"/></param>
            <returns><c>ArrayList</c> as an <c>object</c></returns>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery">
            <summary>
            wrapper for an IMultiQuery that executes a collection of queries.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery"/> class.
            </summary>
            <param name="RootType">the root type for all of the queries that will be included in the <c>IMultiQuery</c></param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery.#ctor(System.Type,Castle.ActiveRecord.ActiveRecordBaseQuery[])">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery"/> class.
            </summary>
            <param name="RootType">the root type for all of the queries that will be included in the <c>IMultiQuery</c></param>
            <param name="activeRecordQueries">an array of <c>IActiveRecordQuery</c></param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery.Add(Castle.ActiveRecord.ActiveRecordBaseQuery)">
            <summary>
            Add an <c>IActiveRecordQuery</c> to our <see cref="T:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery"/>
            </summary>
            <param name="activeRecordQuery"><c>IActiveRecordQuery</c> to be added to the MultiQuery</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery.Execute(NHibernate.ISession)">
            <summary>
            Executes the specified query and return the results
            </summary>
            <param name="session">The session to execute the query in.</param>
            <returns>an array of results, one for each query added</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery.Enumerate(NHibernate.ISession)">
            <summary>
            (Not Implemented!)
            Enumerates over the result of the query.
            Note: Only use if you expect most of your values to already exist in the second level cache!
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.ActiveRecordMultiQuery.RootType">
            <summary>
            Gets the target type of this query
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.CountQuery">
            <summary>
            Query the database for a count (using COUNT(*) ) of all the entites of the specified type.
            Optionally using a where clause;
            Note: If Criteria are used, this query can not be included in a MultiQuery.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.CountQuery.#ctor(System.Type,System.String,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.CountQuery"/> class.
            </summary>
            <param name="targetType">The target type.</param>
            <param name="filter">The filter.</param>
            <param name="parameters">The parameters.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.CountQuery.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.CountQuery"/> class.
            </summary>
            <param name="targetType">The target type.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.CountQuery.#ctor(System.Type,NHibernate.Criterion.ICriterion[])">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.CountQuery"/> class.
            </summary>
            <param name="targetType">The target type.</param>
            <param name="criterias">Criteria applied to the query</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.CountQuery.#ctor(System.Type,NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.CountQuery"/> class.
            </summary>
            <param name="targetType">The target type.</param>
            <param name="detachedCriteria">Criteria applied to the query</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.CountQuery.InternalExecute(NHibernate.ISession)">
            <summary>
            Executes the query.
            </summary>
            <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession"/></param>
            <returns><c>System.Int32</c> as object</returns>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.QueryLanguage">
            <summary>
            defines the possible query langauges
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Queries.QueryLanguage.Hql">
            <summary>
            Hibernate Query Language
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Queries.QueryLanguage.Sql">
            <summary>
            Structured Query Language
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.IActiveRecordQuery`1">
            <summary>
            Represents an ActiveRecord Query.
            </summary>
            <typeparam name="T">The resulting object type</typeparam>
        </member>
        <member name="M:Castle.ActiveRecord.IActiveRecordQuery`1.Execute(NHibernate.ISession)">
            <summary>
            Executes the query using specified session.
            </summary>
            <param name="session">The session.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.ProjectionQuery`2">
            <summary>
            Performs a projected selection from an entity, lifting only the required fields.
            Similar to SELECT Id,Name FROM MyTable instead of selecting everything.
            It is possible to combine this with grouping. 
            </summary>
            <typeparam name="ARType">The active record entity type</typeparam>
            <typeparam name="TResultItem">The result value to use: object[] means returning as is</typeparam>
            /// <example>
            <code>
            <![CDATA[
            ProjectionQuery<Post, PostTitleAndId> proj = new ProjectionQuery<Post, PostTitleAndId>(Projections.Property("Title"), Projections.Property("Id"));
            ICollection<PostTitleAndId> posts = proj.Execute();
            foreach(PostTitleAndId titleAndId in posts)
            {
            	//push to site...
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.#ctor(NHibernate.Criterion.ProjectionList)">
            <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2"/> with the given projections.
            At least one projections must be given
            </summary>
            <param name="projections">The projections to use in the query</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.#ctor(NHibernate.Criterion.DetachedCriteria,NHibernate.Criterion.Order[],NHibernate.Criterion.ProjectionList)">
            <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2"/> with the given projections.
            At least one projections must be given.
            The DetachedCriteria is mostly used for filtering, although it is possible to use it for ordering, limiting the 
            result set, etc.
            Note: Do not call SetProjection() on the detached criteria, since that is overwritten.
            </summary>
            <param name="detachedCriteria">Criteria to select by</param>
            <param name="orders">The order by which to get the result</param>
            <param name="projections">The projections</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.#ctor(NHibernate.Criterion.DetachedCriteria,NHibernate.Criterion.Order,NHibernate.Criterion.ProjectionList)">
            <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2"/> with the given projections.
            At least one projections must be given.
            The DetachedCriteria is mostly used for filtering, although it is possible to use it for ordering, limiting the 
            result set, etc.
            Note: Do not call SetProjection() on the detached criteria, since that is overwritten.
            </summary>
            <param name="detachedCriteria">Criteria to select by</param>
            <param name="order">The order by which to get the result</param>
            <param name="projections">The projections</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.#ctor(NHibernate.Criterion.Order,NHibernate.Criterion.ProjectionList)">
            <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2"/> with the given projections.
            At least one projections must be given.
            The results will be loaded according to the order specified
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.#ctor(NHibernate.Criterion.DetachedCriteria,NHibernate.Criterion.ProjectionList)">
            <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2"/> with the given projections.
            At least one projections must be given.
            The DetachedCriteria is mostly used for filtering, although it is possible to use it for ordering, limiting the 
            result set, etc.
            Note: Do not call SetProjection() on the detached criteria, since that is overwritten.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.SetRange(System.Int32,System.Int32)">
            <summary>
            Sets the query range.
            </summary>
            <param name="first">The first row to return.</param>
            <param name="max">The max number of rows to return.</param>
            <returns>The instance</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.Castle#ActiveRecord#IActiveRecordQuery#Execute(NHibernate.ISession)">
            <summary>
            Executes the specified query and return the results
            </summary>
            <param name="session">The session to execute the query in.</param>
            <returns>IList&lt;TResultItem&gt; cast to object because of interface</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.Enumerate(NHibernate.ISession)">
            <summary>
            Enumerates over the result of the query.
            Note: Only use if you expect most of your values to already exist in the second level cache!
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.Execute">
            <summary>
            Executes the specified query and return the results
            </summary>
            <returns>the result of the query</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.ProjectionQuery`2.RootType">
            <summary>
            Gets the target type of this query
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.ProjectionQuery`2.TypedResultTransformer`1">
            <summary>
            This is used to convert the resulting tuples into strongly typed objects.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`2.TypedResultTransformer`1.TransformTuple(System.Object[],System.String[])">
            <summary>
            Convert the tuples into a strongly typed object
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.ProjectionQuery`1">
            <summary>
            Default implemenation of ProjectionQuery that returns an Untyped object array tuples
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`1.#ctor(NHibernate.Criterion.ProjectionList)">
            <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2"/> with the given projections.
            At least one projections must be given
            </summary>
            <param name="projections">The projections to use in the query</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`1.#ctor(NHibernate.Criterion.DetachedCriteria,NHibernate.Criterion.Order[],NHibernate.Criterion.ProjectionList)">
            <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2"/> with the given projections.
            At least one projections must be given.
            The DetachedCriteria is mostly used for filtering, although it is possible to use it for ordering, limiting the 
            result set, etc.
            Note: Do not call SetProjection() on the detached criteria, since that is overwritten.
            </summary>
            <param name="detachedCriteria">Criteria to select by</param>
            <param name="orders">The order by which to get the result</param>
            <param name="projections">The projections</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`1.#ctor(NHibernate.Criterion.DetachedCriteria,NHibernate.Criterion.Order,NHibernate.Criterion.ProjectionList)">
            <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2"/> with the given projections.
            At least one projections must be given.
            The DetachedCriteria is mostly used for filtering, although it is possible to use it for ordering, limiting the 
            result set, etc.
            Note: Do not call SetProjection() on the detached criteria, since that is overwritten.
            </summary>
            <param name="detachedCriteria">Criteria to select by</param>
            <param name="order">The order by which to get the result</param>
            <param name="projections">The projections</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`1.#ctor(NHibernate.Criterion.Order,NHibernate.Criterion.ProjectionList)">
            <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2"/> with the given projections.
            At least one projections must be given.
            The results will be loaded according to the order specified
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ProjectionQuery`1.#ctor(NHibernate.Criterion.DetachedCriteria,NHibernate.Criterion.ProjectionList)">
            <summary>
            Create a new <see cref="T:Castle.ActiveRecord.Queries.ProjectionQuery`2"/> with the given projections.
            At least one projections must be given.
            The DetachedCriteria is mostly used for filtering, although it is possible to use it for ordering, limiting the 
            result set, etc.
            Note: Do not call SetProjection() on the detached criteria, since that is overwritten.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2">
            <summary>
            Perform a scalar projection ( aggeregate ) type of query:
            avg, max, count(*), etc.
            </summary>
            <typeparam name="ARType">The type of the entity we are querying</typeparam>
            <typeparam name="TResult">The type of the scalar from this query</typeparam>
            <example>
            <code>
            ScalarProjectionQuery&lt;Blog, int&gt; proj = new ScalarProjectionQuery&lt;Blog, int&gt;(Projections.RowCount());
            int rowCount = proj.Execute();
            </code>
            </example>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2.#ctor(NHibernate.Criterion.IProjection,NHibernate.Criterion.ICriterion[])">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2"/> class.
            </summary>
            <param name="projection">The projection.</param>
            <param name="criterions">The criterions.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2.#ctor(NHibernate.Criterion.IProjection,NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2"/> class.
            </summary>
            <param name="projection">The projection.</param>
            <param name="criteria">The detached criteria.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2.Castle#ActiveRecord#IActiveRecordQuery#Execute(NHibernate.ISession)">
            <summary>
            Executes the specified query and return the results
            </summary>
            <param name="session">The session to execute the query in.</param>
            <returns>the result of the query</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2.Enumerate(NHibernate.ISession)">
            <summary>
            Enumerates over the result of the query.
            Always returns a single result
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2.Execute(NHibernate.ISession)">
            <summary>
            Executes the specified query and return the results
            </summary>
            <param name="session">The session to execute the query in.</param>
            <returns>the result of the query</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2.Execute">
            <summary>
            Executes the specified query and return the results
            </summary>
            <returns>the result of the query</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.ScalarProjectionQuery`2.RootType">
            <summary>
            Gets the target type of this query
            </summary>
            <value></value>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.ScalarQuery">
            <summary>
            Query that return a single result
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarQuery.#ctor(System.Type,System.String,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ScalarQuery"/> class.
            </summary>
            <param name="targetType">Type of the target.</param>
            <param name="query">The query.</param>
            <param name="positionalParameters">The positional parameters.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarQuery.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ScalarQuery"/> class.
            </summary>
            <param name="targetType">Type of the target.</param>
            <param name="query">The query.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarQuery.#ctor(System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ScalarQuery"/> class.
            </summary>
            <param name="targetType">Type of the target.</param>
            <param name="queryLanguage">The query language.</param>
            <param name="query">The query.</param>
            <param name="positionalParameters">The positional parameters.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarQuery.#ctor(System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Queries.ScalarQuery"/> class.
            </summary>
            <param name="targetType">Type of the target.</param>
            <param name="queryLanguage">The query language.</param>
            <param name="query">The query.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarQuery.InternalExecute(NHibernate.ISession)">
            <summary>
            Executes the query and returns its scalar result.
            </summary>
            <param name="session">The NHibernate's <see cref="T:NHibernate.ISession"/></param>
            <returns>The query's scalar result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarQuery.InternalEnumerate(NHibernate.ISession)">
            <summary>
            Creates a single-position object array containing 
            the query's scalar result.
            </summary>
            <param name="session">The NHibernate's <see cref="T:NHibernate.ISession"/></param>
            <returns>An <c>object[1]</c> containing the query's scalar result.</returns>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.ScalarQuery`1">
            <summary>
            Represents a query that can result in a value
            of the type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The resulting object type</typeparam>
            <remarks>
            If the query result is null, and <typeparamref name="T"/> is a value type,
            the default value for that type will be returned.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarQuery`1.#ctor(System.Type,System.String,System.Object[])">
            <summary>
            Creates a new <c>ScalarQuery</c> for the giving <paramref name="query"/>,
            using the specified positional <paramref name="positionalParameters"/> and
            the target ActiveRecord type specified in <paramref name="targetType"/>.
            </summary>
            <param name="targetType">The target ActiveRecord type</param>
            <param name="query">The query</param>
            <param name="positionalParameters">The positional positionalParameters</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarQuery`1.#ctor(System.Type,System.String)">
            <summary>
            Creates a new <c>ScalarQuery</c> for the giving <paramref name="query"/> and
            the target ActiveRecord type specified in <paramref name="targetType"/>.
            </summary>
            <param name="targetType">The target ActiveRecord type</param>
            <param name="query">The query</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarQuery`1.#ctor(System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String,System.Object[])">
            <summary>
            Creates a new <c>ScalarQuery</c> for the giving <paramref name="query"/>,
            using the specified positional <paramref name="positionalParameters"/> and
            the target ActiveRecord type specified in <paramref name="targetType"/>.
            </summary>
            <param name="targetType">The target ActiveRecord type</param>
            <param name="queryLanguage">The language of the query</param>
            <param name="query">The query</param>
            <param name="positionalParameters">The positional positionalParameters</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarQuery`1.#ctor(System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String)">
            <summary>
            Creates a new <c>ScalarQuery</c> for the giving <paramref name="query"/> and
            the target ActiveRecord type specified in <paramref name="targetType"/>.
            </summary>
            <param name="targetType">The target ActiveRecord type</param>
            <param name="queryLanguage">The language of the query</param>
            <param name="query">The query</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ScalarQuery`1.Execute">
            <summary>
            Executes the query and gets the result.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.SimpleQuery">
            <summary>
            Simple query.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery.#ctor(System.Type,System.Type,System.String,System.Object[])">
            <summary>
            Creates a new <c>SimpleQuery</c>.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery.#ctor(System.Type,System.String,System.Object[])">
            <summary>
            Creates a new <c>SimpleQuery</c>.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery.#ctor(System.Type,System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String,System.Object[])">
            <summary>
            Creates a new <c>SimpleQuery</c>.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery.#ctor(System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String,System.Object[])">
            <summary>
            Creates a new <c>SimpleQuery</c>.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery.InternalExecute(NHibernate.ISession)">
            <summary>
            Executes the query and converts the results into a strongly-typed
            array of <see cref="F:Castle.ActiveRecord.Queries.SimpleQuery.returnType"/>.
            </summary>
            <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession"/></param>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.SimpleQuery`1">
            <summary>
            Represents a query that can result in an array of 
            objects of the type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The resulting object type</typeparam>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.#ctor(System.String,System.Object[])">
            <summary>
            Creates a new <c>SimpleQuery</c> for the giving <paramref name="query"/>,
            using the specified positional <paramref name="positionalParameters"/>.
            The target ActiveRecord type is <typeparamref name="T"/>.
            </summary>
            <param name="query">The query</param>
            <param name="positionalParameters">The positional parameters</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.#ctor(Castle.ActiveRecord.Queries.QueryLanguage,System.String,System.Object[])">
            <summary>
            Creates a new <c>SimpleQuery</c> for the giving <paramref name="query"/>,
            using the specified positional <paramref name="positionalParameters"/>.
            The target ActiveRecord type is <typeparamref name="T"/>.
            </summary>
            <param name="query">The query</param>
            <param name="queryLanguage">The query language</param>
            <param name="positionalParameters">The positional parameters</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.#ctor(System.Type,System.String,System.Object[])">
            <summary>
            Creates a new <c>SimpleQuery</c> for the giving <paramref name="query"/>,
            using the specified positional <paramref name="positionalParameters"/> and
            the target ActiveRecord type specified in <paramref name="targetType"/>.
            </summary>
            <param name="targetType">The target ActiveRecord type</param>
            <param name="query">The query</param>
            <param name="positionalParameters">The positional parameters</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.#ctor(System.Type,Castle.ActiveRecord.Queries.QueryLanguage,System.String,System.Object[])">
            <summary>
            Creates a new <c>SimpleQuery</c> for the giving <paramref name="query"/>,
            using the specified positional <paramref name="positionalParameters"/> and
            the target ActiveRecord type specified in <paramref name="targetType"/>.
            </summary>
            <param name="targetType">The target ActiveRecord type</param>
            <param name="queryLanguage">The query language</param>
            <param name="query">The query</param>
            <param name="positionalParameters">The positional parameters</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.Execute">
            <summary>
            Executes the query and gets the results.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.Enumerate">
            <summary>
            Enumerates the query results. Better suited for queries 
            which might return large results.
            <seealso cref="M:NHibernate.IQuery.Enumerable"/>
            </summary>
            <remarks>
            It might not look obvious at first, but 
            <see cref="T:Castle.ActiveRecord.ActiveRecordMediator"/> will call our 
            <see cref="M:Castle.ActiveRecord.Queries.SimpleQuery`1.InternalEnumerate(NHibernate.ISession)"/>, which will call our 
            <see cref="M:Castle.ActiveRecord.Queries.SimpleQuery`1.GenericEnumerate(NHibernate.ISession)"/>, which will convert
            the <c>NHibernate</c>'s <see cref="M:NHibernate.IQuery.Enumerable"/> result
            returned by <see cref="M:Castle.ActiveRecord.ActiveRecordBaseQuery.InternalEnumerate(NHibernate.ISession)"/>
            into a generic <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            So, all we need to do is to cast it back to <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.InternalEnumerate(NHibernate.ISession)">
            <summary>
            Simply creates the query and then call its <see cref="M:NHibernate.IQuery.Enumerable"/> method.
            Note: Only use when you expect most of the results to be in the second level cache
            </summary>
            <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession"/></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.InternalEnumerateFromBase(NHibernate.ISession)">
            <summary>
            Needed to avoid <c>CS1911</c>.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.SimpleQuery`1.InternalExecute(NHibernate.ISession)">
            <summary>
            Executes the query and converts the results into a strongly-typed
            array of <typeparamref name="T"/>.
            </summary>
            <param name="session">The <c>NHibernate</c>'s <see cref="T:NHibernate.ISession"/></param>
        </member>
        <member name="T:Castle.ActiveRecord.Queries.ValueAndTypeTuple">
            <summary>
            Represents a query parameter value and type. Can be used to override the 
            standard mechanism of determing parameter types.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ValueAndTypeTuple.#ctor(System.Object)">
            <summary>
            Creates a new instance of ValueAndTypeTuple with no specific Type
            </summary>
            <param name="value">The value of the parameter</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ValueAndTypeTuple.#ctor(NHibernate.Type.IType,System.Object)">
            <summary>
            Creates a new instance of ValueAndTypeTuple with a specific Type
            </summary>
            <param name="type">The type of the parameter</param>
            <param name="value">The value of the parameter</param>
        </member>
        <member name="M:Castle.ActiveRecord.Queries.ValueAndTypeTuple.Wrap(System.Object)">
            <summary>
            Creates a new ValueAndTypeTuple using the argument as the value
            unless the argument is already a ValueAndTypeTuple, in which case
            that is returned unmodified.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.ValueAndTypeTuple.Type">
            <summary>
            The parameter type
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Queries.ValueAndTypeTuple.Value">
            <summary>
            The parameter value
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.AbstractScope">
            <summary>
            Abstract <seealso cref="T:Castle.ActiveRecord.ISessionScope"/> implementation
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ISessionScope">
            <summary>
            Contract for implementation of scopes.
            </summary>
            <remarks>
            A scope can implement a logic that affects 
            AR for the scope lifetime. Session cache and
            transaction are the best examples, but you 
            can create new scopes adding new semantics.
            <para>
            The methods on this interface are mostly invoked
            by the <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            implementation
            </para>
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ISessionScope.Flush">
            <summary>
            Flushes the sessions that this scope 
            is maintaining
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ISessionScope.Evict(System.Object)">
            <summary>
            Evicts the specified instance from the session cache. 
            </summary>
            <param name="instance">The instance.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ISessionScope.RegisterSession(System.Object,NHibernate.ISession)">
            <summary>
            This method is invoked when no session was available
            at and the <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            just created one. So it registers the session created 
            within this scope using a key. The scope implementation
            shouldn't make any assumption on what the key
            actually is as we reserve the right to change it 
            <seealso cref="M:Castle.ActiveRecord.ISessionScope.IsKeyKnown(System.Object)"/>
            </summary>
            <param name="key">an object instance</param>
            <param name="session">An instance of <c>ISession</c></param>
        </member>
        <member name="M:Castle.ActiveRecord.ISessionScope.IsKeyKnown(System.Object)">
            <summary>
            This method is invoked when the 
            <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            instance needs a session instance. Instead of creating one it interrogates
            the active scope for one. The scope implementation must check if it
            has a session registered for the given key. 
            <seealso cref="M:Castle.ActiveRecord.ISessionScope.RegisterSession(System.Object,NHibernate.ISession)"/>
            </summary>
            <param name="key">an object instance</param>
            <returns><c>true</c> if the key exists within this scope instance</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ISessionScope.GetSession(System.Object)">
            <summary>
            This method should return the session instance associated with the key.
            </summary>
            <param name="key">an object instance</param>
            <returns>the session instance or null if none was found</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ISessionScope.OpenSession(NHibernate.ISessionFactory,NHibernate.IInterceptor)">
            <summary>
            If the <see cref="P:Castle.ActiveRecord.ISessionScope.WantsToCreateTheSession"/> returned
            <c>true</c> then this method is invoked to allow 
            the scope to create a properly configured session
            </summary>
            <param name="sessionFactory">From where to open the session</param>
            <param name="interceptor">the NHibernate interceptor</param>
            <returns>the newly created session</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ISessionScope.FailSession(NHibernate.ISession)">
            <summary>
            This method will be called if a session action fails. 
            The scope may then decide to use an different approach to flush/dispose it.
            </summary>
            <param name="session">The session that failed</param>
        </member>
        <member name="P:Castle.ActiveRecord.ISessionScope.FlushAction">
            <summary>
            Returns the <see cref="P:Castle.ActiveRecord.ISessionScope.FlushAction"/> defined 
            for this scope
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ISessionScope.ScopeType">
            <summary>
            Returns the <see cref="T:Castle.ActiveRecord.SessionScopeType"/> defined 
            for this scope
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ISessionScope.WantsToCreateTheSession">
            <summary>
            Implementors should return true if they
            want that their scope implementation 
            be in charge of creating the session
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.Scopes.AbstractScope.key2Session">
            <summary>
            Map between a key to its session
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.#ctor(Castle.ActiveRecord.FlushAction,Castle.ActiveRecord.SessionScopeType)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Scopes.AbstractScope"/> class.
            </summary>
            <param name="flushAction">The flush action.</param>
            <param name="type">The type.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.Flush">
            <summary>
            Flushes the sessions that this scope 
            is maintaining
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.Evict(System.Object)">
            <summary>
            Evicts the specified instance from the session cache.
            </summary>
            <param name="instance">The instance.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.IsKeyKnown(System.Object)">
            <summary>
            This method is invoked when the
            <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            instance needs a session instance. Instead of creating one it interrogates
            the active scope for one. The scope implementation must check if it
            has a session registered for the given key.
            <seealso cref="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.RegisterSession(System.Object,NHibernate.ISession)"/>
            </summary>
            <param name="key">an object instance</param>
            <returns>
            	<c>true</c> if the key exists within this scope instance
            </returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.RegisterSession(System.Object,NHibernate.ISession)">
            <summary>
            This method is invoked when no session was available
            at and the <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            just created one. So it registers the session created
            within this scope using a key. The scope implementation
            shouldn't make any assumption on what the key
            actually is as we reserve the right to change it
            <seealso cref="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.IsKeyKnown(System.Object)"/>
            </summary>
            <param name="key">an object instance</param>
            <param name="session">An instance of <c>ISession</c></param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.GetSession(System.Object)">
            <summary>
            This method should return the session instance associated with the key.
            </summary>
            <param name="key">an object instance</param>
            <returns>
            the session instance or null if none was found
            </returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.OpenSession(NHibernate.ISessionFactory,NHibernate.IInterceptor)">
            <summary>
            If the <see cref="P:Castle.ActiveRecord.Framework.Scopes.AbstractScope.WantsToCreateTheSession"/> returned
            <c>true</c> then this method is invoked to allow
            the scope to create a properly configured session
            </summary>
            <param name="sessionFactory">From where to open the session</param>
            <param name="interceptor">the NHibernate interceptor</param>
            <returns>the newly created session</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.Initialize(NHibernate.ISession)">
            <summary>
            Initializes the specified session.
            </summary>
            <param name="session">The session.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.PerformDisposal(System.Collections.Generic.ICollection{NHibernate.ISession})">
            <summary>
            Performs the disposal.
            </summary>
            <param name="sessions">The sessions.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.PerformDisposal(System.Collections.Generic.ICollection{NHibernate.ISession},System.Boolean,System.Boolean)">
            <summary>
            Performs the disposal.
            </summary>
            <param name="sessions">The sessions.</param>
            <param name="flush">if set to <c>true</c> [flush].</param>
            <param name="close">if set to <c>true</c> [close].</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.DiscardSessions(System.Collections.Generic.ICollection{NHibernate.ISession})">
            <summary>
            Discards the sessions.
            </summary>
            <param name="sessions">The sessions.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.FailSession(NHibernate.ISession)">
            <summary>
            Marks the session as failed
            </summary>
            <param name="session">The session</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.SetFlushMode(NHibernate.ISession)">
            <summary>
            Sets the flush mode.
            </summary>
            <param name="session">The session.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.ResetFlushMode">
            <summary>
            Notifies the scope that an inner scope that changed the flush mode, was
            disposed. The scope should reset the flush mode to its default.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.GetSessions">
            <summary>
            Gets the sessions.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractScope.RemoveSession(NHibernate.ISession)">
            <summary>
            Removes the session.
            </summary>
            <param name="session">The session.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Scopes.AbstractScope.ScopeType">
            <summary>
            Returns the <see cref="T:Castle.ActiveRecord.SessionScopeType"/> defined 
            for this scope
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Scopes.AbstractScope.FlushAction">
            <summary>
            Returns the <see cref="P:Castle.ActiveRecord.ISessionScope.FlushAction"/> defined 
            for this scope
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Scopes.AbstractScope.WantsToCreateTheSession">
            <summary>
            Implementors should return true if they
            want that their scope implementation
            be in charge of creating the session
            </summary>
            <value></value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.AbstractThreadScopeInfo">
            <summary>
            Base <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/> implementation. It's up 
            to derived classes to provide a correct implementation 
            of <c>CurrentStack</c> only
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.IThreadScopeInfo">
            <summary>
            Implementation of this interface provide a way to get the current scope.
            This is used by the rest of the Active Record framework to grab a scope (and from it a session).
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.IThreadScopeInfo.GetRegisteredScope">
            <summary>
            Gets the registered scope.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.IThreadScopeInfo.RegisterScope(Castle.ActiveRecord.ISessionScope)">
            <summary>
            Registers the scope.
            </summary>
            <param name="scope">The scope.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.IThreadScopeInfo.UnRegisterScope(Castle.ActiveRecord.ISessionScope)">
            <summary>
            Unregister the scope.
            </summary>
            <param name="scope">The scope.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IThreadScopeInfo.CurrentStack">
            <summary>
            Gets the current stack.
            </summary>
            <value>The current stack.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IThreadScopeInfo.HasInitializedScope">
            <summary>
            Gets a value indicating whether this instance has initialized scope.
            </summary>
            <value>
            	<c>true</c> if this instance has initialized scope; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractThreadScopeInfo.RegisterScope(Castle.ActiveRecord.ISessionScope)">
            <summary>
            Registers the scope.
            </summary>
            <param name="scope">The scope.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractThreadScopeInfo.GetRegisteredScope">
            <summary>
            Gets the registered scope.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.AbstractThreadScopeInfo.UnRegisterScope(Castle.ActiveRecord.ISessionScope)">
            <summary>
            Unregister the scope.
            </summary>
            <param name="scope">The scope.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Scopes.AbstractThreadScopeInfo.CurrentStack">
            <summary>
            Gets the current stack.
            </summary>
            <value>The current stack.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Scopes.AbstractThreadScopeInfo.HasInitializedScope">
            <summary>
            Gets a value indicating whether this instance has initialized scope.
            </summary>
            <value>
            	<c>true</c> if this instance has initialized scope; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope">
            <summary>
            Still very experimental and it's not bullet proof
            for all situations
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.#ctor(System.Data.IDbConnection)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope"/> class.
            </summary>
            <param name="connection">The connection.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.#ctor(System.Data.IDbConnection,Castle.ActiveRecord.FlushAction)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope"/> class.
            </summary>
            <param name="connection">The connection.</param>
            <param name="flushAction">The flush action.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.RegisterSession(System.Object,NHibernate.ISession)">
            <summary>
            This method is invoked when no session was available
            at and the <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            just created one. So it registers the session created
            within this scope using a key. The scope implementation
            shouldn't make any assumption on what the key
            actually is as we reserve the right to change it
            <seealso cref="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.IsKeyKnown(System.Object)"/>
            </summary>
            <param name="key">an object instance</param>
            <param name="session">An instance of <c>ISession</c></param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.IsKeyKnown(System.Object)">
            <summary>
            This method is invoked when the
            <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            instance needs a session instance. Instead of creating one it interrogates
            the active scope for one. The scope implementation must check if it
            has a session registered for the given key.
            <seealso cref="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.RegisterSession(System.Object,NHibernate.ISession)"/>
            </summary>
            <param name="key">an object instance</param>
            <returns>
            	<c>true</c> if the key exists within this scope instance
            </returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.GetSession(System.Object)">
            <summary>
            This method should return the session instance associated with the key.
            </summary>
            <param name="key">an object instance</param>
            <returns>
            the session instance or null if none was found
            </returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.PerformDisposal(System.Collections.Generic.ICollection{NHibernate.ISession})">
            <summary>
            Performs the disposal.
            </summary>
            <param name="sessions">The sessions.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.OpenSession(NHibernate.ISessionFactory,NHibernate.IInterceptor)">
            <summary>
            If the <see cref="P:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.WantsToCreateTheSession"/> returned
            <c>true</c> then this method is invoked to allow
            the scope to create a properly configured session
            </summary>
            <param name="sessionFactory">From where to open the session</param>
            <param name="interceptor">the NHibernate interceptor</param>
            <returns>the newly created session</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.FailSession(NHibernate.ISession)">
            <summary>
            This is called when a session has a failure
            </summary>
            <param name="session">the session</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Scopes.DifferentDatabaseScope.WantsToCreateTheSession">
            <summary>
            We want to be in charge of creating the session
            </summary>
            <value></value>
        </member>
        <member name="T:Castle.ActiveRecord.FlushAction">
            <summary>
            Pendent
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.FlushAction.Auto">
            <summary>
            Original behavior. Changes are persisted at the 
            end or before some queries.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.FlushAction.Never">
            <summary>
            Flush need to be controlled manually. Best choice
            for readonly operations
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.FlushAction.Config">
            <summary>
            Determine the flushing behaviour from configuration.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.HybridWebThreadScopeInfo">
            <summary>
            This <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/> implementation will first try to get the current scope from the current 
            request, and if not found, will use a thread lcoal scope.
            </summary>
            <remarks>
            This is used for scenarios where most of the you need per request scope, but you also does some work outside a 
            request (in a thread pool thread, for instnace).
            </remarks>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.IWebThreadScopeInfo">
            <summary>
            Implemenation of this interface provides <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/> that is compatible 
            with Session Per Request pattern.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Scopes.HybridWebThreadScopeInfo.CurrentStack">
            <summary>
            Gets the current stack.
            </summary>
            <value>The current stack.</value>
        </member>
        <member name="T:Castle.ActiveRecord.SessionScopeType">
            <summary>
            Define session scope types
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.SessionScopeType.Undefined">
            <summary>
            Undefined type of session scope.
            This value probably should never exist
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.SessionScopeType.Simple">
            <summary>
            Simple - non transactional session scope
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.SessionScopeType.Transactional">
            <summary>
            Transactional session scope
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.SessionScopeType.Custom">
            <summary>
            Custom implementation of session scope.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.ScopeMachineryException">
            <summary>
            This exception is raised when something went wrong with the scope management.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.ScopeMachineryException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Scopes.ScopeMachineryException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.ScopeMachineryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Scopes.ScopeMachineryException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"></see> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"></see> is zero (0). </exception>
            <exception cref="T:System.ArgumentNullException">The info parameter is null. </exception>
        </member>
        <member name="T:Castle.ActiveRecord.SessionScope">
            <summary>
            Implementation of <see cref="T:Castle.ActiveRecord.ISessionScope"/> to 
            augment performance by caching the session, thus
            avoiding too much opens/flushes/closes.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.SessionScope.hasSessionError">
            <summary>
            Is set to true if the session went stalled due to an error (usually db operations)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.SessionScope.#ctor(Castle.ActiveRecord.FlushAction,Castle.ActiveRecord.SessionScopeType)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.SessionScope"/> class.
            </summary>
            <param name="flushAction">The flush action.</param>
            <param name="type">The type.</param>
        </member>
        <member name="M:Castle.ActiveRecord.SessionScope.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.SessionScope"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.SessionScope.#ctor(Castle.ActiveRecord.FlushAction)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.SessionScope"/> class.
            </summary>
            <param name="flushAction">The flush action.</param>
        </member>
        <member name="M:Castle.ActiveRecord.SessionScope.Dispose(System.Boolean)">
            <summary>
            Deprecated! Disposes the specified discard changes. Please use new SessionScope(FlushAction.Never)
            </summary>
            <param name="discardChanges">if set to <c>true</c> [discard changes].</param>
        </member>
        <member name="M:Castle.ActiveRecord.SessionScope.PerformDisposal(System.Collections.Generic.ICollection{NHibernate.ISession})">
            <summary>
            Performs the disposal.
            </summary>
            <param name="sessions">The sessions.</param>
        </member>
        <member name="M:Castle.ActiveRecord.SessionScope.FailSession(NHibernate.ISession)">
            <summary>
            This is called when an action on a session fails
            </summary>
            <param name="session">The session</param>
        </member>
        <member name="P:Castle.ActiveRecord.SessionScope.HasSessionError">
            <summary>
            Gets or sets a flag indicating whether this instance has session error.
            </summary>
            <value>
            	<c>true</c> if this instance has session error; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.ActiveRecord.SessionScope.Current">
            <summary>
            Gets the current scope
            </summary>
            <value>The current.</value>
        </member>
        <member name="T:Castle.ActiveRecord.StatelessSessionScope">
            <summary>
            Implementation of <see cref="T:Castle.ActiveRecord.ISessionScope"/> with
            an IStatelessSession to improve performance 
            by caching a session without a first-level-cache.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.StatelessSessionScope.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.StatelessSessionScope"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.StatelessSessionScope.OpenSession(NHibernate.ISessionFactory,NHibernate.IInterceptor)">
            <summary>
            If the <see cref="P:Castle.ActiveRecord.Framework.Scopes.AbstractScope.WantsToCreateTheSession"/> returned
            <c>true</c> then this method is invoked to allow
            the scope to create a properly configured session
            </summary>
            <param name="sessionFactory">From where to open the session</param>
            <param name="interceptor">the NHibernate interceptor</param>
            <returns>the newly created session</returns>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor">
            <summary>
            Class to allow scopes to reach the implementation
            of <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/>. Also implements 
            the <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/> delegating the calls to 
            the scope set.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor.GetRegisteredScope">
            <summary>
            Gets the registered scope.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor.RegisterScope(Castle.ActiveRecord.ISessionScope)">
            <summary>
            Registers the scope.
            </summary>
            <param name="scope">The scope.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor.UnRegisterScope(Castle.ActiveRecord.ISessionScope)">
            <summary>
            Unregister the scope.
            </summary>
            <param name="scope">The scope.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor.Instance">
            <summary>
            Gets the single instance.
            </summary>
            <value>The instance.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor.ScopeInfo">
            <summary>
            Gets or sets the scope info.
            </summary>
            <value>The scope info.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor.CurrentStack">
            <summary>
            Gets the current stack.
            </summary>
            <value>The current stack.</value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Scopes.ThreadScopeAccessor.HasInitializedScope">
            <summary>
            Gets a value indicating whether this instance has initialized scope.
            </summary>
            <value>
            	<c>true</c> if this instance has initialized scope; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.ThreadScopeInfo">
            <summary>
            This <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/> implementation will first get the current scope from the current 
            thread. Do NOT use on web scenario (web applications or web services).
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Scopes.ThreadScopeInfo.CurrentStack">
            <summary>
            Gets the current stack.
            </summary>
            <value>The current stack.</value>
        </member>
        <member name="T:Castle.ActiveRecord.TransactionMode">
            <summary>
            Defines the transaction scope behavior
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.TransactionMode.Inherits">
            <summary>
            Inherits a transaction previously create on 
            the current context.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.TransactionMode.New">
            <summary>
            Always create an isolated transaction context.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.OnDispose">
            <summary>
            Governs the <see cref="T:Castle.ActiveRecord.TransactionScope"/> behavior 
            on dispose if neither <see cref="M:Castle.ActiveRecord.TransactionScope.VoteCommit"/>
            nor <see cref="M:Castle.ActiveRecord.TransactionScope.VoteRollBack"/> was called
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.OnDispose.Commit">
            <summary>
            Should commit the transaction, unless <see cref="M:Castle.ActiveRecord.TransactionScope.VoteRollBack"/>
            was called before the disposing the scope (this is the default behavior)
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.OnDispose.Rollback">
            <summary>
            Should rollback the transaction, unless <see cref="M:Castle.ActiveRecord.TransactionScope.VoteCommit"/>
            was called before the disposing the scope
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.TransactionScope">
            <summary>
            Implementation of <see cref="T:Castle.ActiveRecord.ISessionScope"/> to 
            provide transaction semantics
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.TransactionScope"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.#ctor(Castle.ActiveRecord.OnDispose)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.TransactionScope"/> class.
            </summary>
            <param name="onDisposeBehavior">The on dispose behavior.</param>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.#ctor(Castle.ActiveRecord.TransactionMode)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.TransactionScope"/> class.
            </summary>
            <param name="mode">Whatever to create a new transaction or inherits an existing one</param>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.#ctor(Castle.ActiveRecord.TransactionMode,Castle.ActiveRecord.OnDispose)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.TransactionScope"/> class.
            </summary>
            <param name="mode">Whatever to create a new transaction or inherits an existing one</param>
            <param name="onDisposeBehavior">The on dispose behavior.</param>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.#ctor(Castle.ActiveRecord.TransactionMode,System.Data.IsolationLevel,Castle.ActiveRecord.OnDispose)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.TransactionScope"/> class.
            </summary>
            <param name="mode">Whatever to create a new transaction or inherits an existing one</param>
            <param name="isolationLevel">The transaction isolation level.</param>
            <param name="onDisposeBehavior">The on dispose behavior.</param>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.VoteRollBack">
            <summary>
            Votes to roll back the transaction
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.VoteCommit">
            <summary>
            Votes to commit the transaction
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.IsKeyKnown(System.Object)">
            <summary>
            This method is invoked when the
            <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            instance needs a session instance. Instead of creating one it interrogates
            the active scope for one. The scope implementation must check if it
            has a session registered for the given key.
            <seealso cref="M:Castle.ActiveRecord.TransactionScope.RegisterSession(System.Object,NHibernate.ISession)"/>
            </summary>
            <param name="key">an object instance</param>
            <returns>
            	<c>true</c> if the key exists within this scope instance
            </returns>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.RegisterSession(System.Object,NHibernate.ISession)">
            <summary>
            This method is invoked when no session was available
            at and the <see cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            just created one. So it registers the session created
            within this scope using a key. The scope implementation
            shouldn't make any assumption on what the key
            actually is as we reserve the right to change it
            <seealso cref="M:Castle.ActiveRecord.TransactionScope.IsKeyKnown(System.Object)"/>
            </summary>
            <param name="key">an object instance</param>
            <param name="session">An instance of <c>ISession</c></param>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.GetSession(System.Object)">
            <summary>
            This method should return the session instance associated with the key.
            </summary>
            <param name="key">an object instance</param>
            <returns>
            the session instance or null if none was found
            </returns>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.Flush">
            <summary>
            Flushes the sessions that this scope 
            or its parents are maintaining
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.EnsureHasTransaction(NHibernate.ISession)">
            <summary>
            Ensures that a transaction exist, creating one if neccecary
            </summary>
            <param name="session">The session.</param>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.Initialize(NHibernate.ISession)">
            <summary>
            Initializes the current transaction scope using the session
            </summary>
            <param name="session">The session.</param>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.PerformDisposal(System.Collections.Generic.ICollection{NHibernate.ISession})">
            <summary>
            Dispose of this scope
            </summary>
            <param name="sessions">The sessions.</param>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.FailSession(NHibernate.ISession)">
            <summary>
            This is called when a session has a failure
            </summary>
            <param name="session">the session</param>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.DiscardSessions(System.Collections.Generic.ICollection{NHibernate.ISession})">
            <summary>
            Discards the sessions.
            </summary>
            <param name="sessions">The sessions.</param>
        </member>
        <member name="M:Castle.ActiveRecord.TransactionScope.RaiseOnCompleted">
            <summary>
            Raises the on completed event
            </summary>
        </member>
        <member name="E:Castle.ActiveRecord.TransactionScope.OnTransactionCompleted">
            <summary>
            This event is raised when a transaction is completed
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Scopes.WebThreadScopeInfo">
            <summary>
            This <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/> implementation will first get the current scope from the current 
            request, thus implementing a Session Per Request pattern.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Scopes.WebThreadScopeInfo.CurrentStack">
            <summary>
            Gets the current stack.
            </summary>
            <value>The current stack.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Validators.IsUniqueValidator">
            <summary>
            Validate that the property's value is unique in the database when saved
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Validators.IsUniqueValidator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Validators.IsUniqueValidator"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Validators.IsUniqueValidator.IsValid(System.Object,System.Object)">
            <summary>
            Perform the check that the property value is unqiue in the table
            </summary>
            <param name="instance"></param>
            <param name="fieldValue"></param>
            <returns><c>true</c> if the field is OK</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Validators.IsUniqueValidator.BuildErrorMessage">
            <summary>
            Builds the error message when the property value is not unique
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Validators.IsUniqueValidator.ApplyBrowserValidation(Castle.Components.Validator.BrowserValidationConfiguration,Castle.Components.Validator.InputElementType,Castle.Components.Validator.IBrowserValidationGenerator,System.Collections.IDictionary,System.String)">
            <summary>
            Applies the browser validation by setting up one or
            more input rules on <see cref="T:Castle.Components.Validator.IBrowserValidationGenerator"/>.
            </summary>
            <param name="config">The config.</param>
            <param name="inputType">Type of the input.</param>
            <param name="generator">The generator.</param>
            <param name="attributes">The attributes.</param>
            <param name="target">The target.</param>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.Validators.IsUniqueValidator.SupportsBrowserValidation">
            <summary>
            Gets a value indicating whether this validator supports browser validation.
            </summary>
            <value>
            	<see langword="true"/> if browser validation is supported; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="T:Castle.ActiveRecord.NHibernateDelegate">
            <summary>
            Allow custom executions using the NHibernate's ISession.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordBase">
            <summary>
            Base class for all ActiveRecord classes. Implements 
            all the functionality to simplify the code on the 
            subclasses.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordHooksBase">
            <summary>
            Base class for ActiveRecord entities
            that are interested in NHibernate's hooks.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.BeforeSave(System.Collections.IDictionary)">
            <summary>
            Hook to change the object state
            before saving it.
            </summary>
            <param name="state"></param>
            <returns>Return <c>true</c> if you have changed the state. <c>false</c> otherwise</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.BeforeLoad(System.Object,System.Collections.IDictionary)">
            <summary>
            Hook to transform the read data 
            from the database before populating 
            the object instance
            </summary>
            <param name="id">id of the obejct</param>
            <param name="adapter">list of properties and their values</param>
            <returns>Return <c>true</c> if you have changed the state. <c>false</c> otherwise</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.BeforeDelete(System.Collections.IDictionary)">
            <summary>
            Hook to perform additional tasks 
            before removing the object instance representation
            from the database.
            </summary>
            <param name="adapter"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.PreFlush">
            <summary>
            Called before a flush
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.PostFlush">
            <summary>
            Called after a flush that actually ends in execution of the SQL statements required to
            synchronize in-memory state with the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.IsUnsaved">
            <summary>
            Called when a transient entity is passed to <c>SaveOrUpdate</c>.
            </summary>
            <remarks>
            The return value determines if the object is saved
            <list>
            	<item><see langword="true" /> - the entity is passed to <c>Save()</c>, resulting in an <c>INSERT</c></item>
            	<item><see langword="false" /> - the entity is passed to <c>Update()</c>, resulting in an <c>UPDATE</c></item>
            	<item><see langword="null" /> - Hibernate uses the <c>unsaved-value</c> mapping to determine if the object is unsaved</item>
            </list>
            </remarks>
            <returns>Boolean or <see langword="null" /> to choose default behaviour</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.FindDirty(System.Object,System.Collections.IDictionary,System.Collections.IDictionary,NHibernate.Type.IType[])">
            <summary>
            Called from <c>Flush()</c>. The return value determines whether the entity is updated
            </summary>
            <remarks>
            	<list>
            		<item>an array of property indicies - the entity is dirty</item>
            		<item>an empty array - the entity is not dirty</item>
            		<item><c>null</c> - use Hibernate's default dirty-checking algorithm</item>
            	</list>
            </remarks>
            <param name="id"></param>
            <param name="previousState"></param>
            <param name="currentState"></param>
            <param name="types"></param>
            <returns>An array of dirty property indicies or <c>null</c> to choose default behavior</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.OnFlushDirty(System.Object,System.Collections.IDictionary,System.Collections.IDictionary,NHibernate.Type.IType[])">
            <summary>
            
            </summary>
            <param name="id"></param>
            <param name="previousState"></param>
            <param name="currentState"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.OnSave">
            <summary>
            Lifecycle method invoked during Save of the entity
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.OnUpdate">
            <summary>
            Lifecycle method invoked during Update of the entity
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.OnDelete">
            <summary>
            Lifecycle method invoked during Delete of the entity
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksBase.OnLoad(System.Object)">
            <summary>
            Lifecycle method invoked during Load of the entity
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.ActiveRecordBase.holder">
            <summary>
            The global holder for the session factories.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Register(System.Type,Castle.ActiveRecord.Framework.Internal.ActiveRecordModel)">
            <summary>
            Internally used
            </summary>
            <param name="arType">The type.</param>
            <param name="model">The model.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.GetModel(System.Type)">
            <summary>
            Internally used
            </summary>
            <param name="arType">The type.</param>
            <returns>An <see cref="T:Castle.ActiveRecord.Framework.Internal.ActiveRecordModel"/></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Create(System.Object)">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
            <param name="instance">The ActiveRecord instance to be created on the database</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.CreateAndFlush(System.Object)">
            <summary>
            Creates (Saves) a new instance to the database and flushes the session.
            </summary>
            <param name="instance">The ActiveRecord instance to be created on the database</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.InternalCreate(System.Object,System.Boolean)">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
            <param name="instance">The ActiveRecord instance to be created on the database</param>
            <param name="flush">if set to <c>true</c>, the operation will be followed by a session flush.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Delete(System.Object)">
            <summary>
            Deletes the instance from the database.
            </summary>
            <param name="instance">The ActiveRecord instance to be deleted</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.DeleteAndFlush(System.Object)">
            <summary>
            Deletes the instance from the database and flushes the session.
            </summary>
            <param name="instance">The ActiveRecord instance to be deleted</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.InternalDelete(System.Object,System.Boolean)">
            <summary>
            Deletes the instance from the database.
            </summary>
            <param name="instance">The ActiveRecord instance to be deleted</param>
            <param name="flush">if set to <c>true</c>, the operation will be followed by a session flush.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Replicate(System.Object,NHibernate.ReplicationMode)">
            <summary>
            From NHibernate documentation: 
            Persist all reachable transient objects, reusing the current identifier 
            values. Note that this will not trigger the Interceptor of the Session.
            </summary>
            <param name="instance">The instance.</param>
            <param name="replicationMode">The replication mode.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Refresh(System.Object)">
            <summary>
            Refresh the instance from the database.
            </summary>
            <param name="instance">The ActiveRecord instance to be reloaded</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.DeleteAll(System.Type)">
            <summary>
            Deletes all rows for the specified ActiveRecord type
            </summary>
            <remarks>
            This method is usually useful for test cases.
            </remarks>
            <param name="type">ActiveRecord type on which the rows on the database should be deleted</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.DeleteAll(System.Type,System.String)">
            <summary>
            Deletes all rows for the specified ActiveRecord type that matches
            the supplied HQL condition
            </summary>
            <remarks>
            This method is usually useful for test cases.
            </remarks>
            <param name="type">ActiveRecord type on which the rows on the database should be deleted</param>
            <param name="where">HQL condition to select the rows to be deleted</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.DeleteAll(System.Type,System.Collections.IEnumerable)">
            <summary>
            Deletes all <paramref name="targetType" /> objects, based on the primary keys
            supplied on <paramref name="pkValues" />.
            </summary>
            <param name="targetType">The target ActiveRecord type</param>
            <param name="pkValues">A list of primary keys</param>
            <returns>The number of objects deleted</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Update(System.Object)">
            <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
            <param name="instance">The ActiveRecord instance to be updated on the database</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.UpdateAndFlush(System.Object)">
            <summary>
            Persists the modification on the instance
            state to the database and flushes the session.
            </summary>
            <param name="instance">The ActiveRecord instance to be updated on the database</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.InternalUpdate(System.Object,System.Boolean)">
            <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
            <param name="instance">The ActiveRecord instance to be updated on the database</param>
            <param name="flush">if set to <c>true</c>, the operation will be followed by a session flush.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Save(System.Object)">
            <summary>
            Saves the instance to the database. If the primary key is unitialized
            it creates the instance on the database. Otherwise it updates it.
            <para>
            If the primary key is assigned, then you must invoke <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Create"/>
            or <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Update"/> instead.
            </para>
            </summary>
            <param name="instance">The ActiveRecord instance to be saved</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.SaveAndFlush(System.Object)">
            <summary>
            Saves the instance to the database and flushes the session. If the primary key is unitialized
            it creates the instance on the database. Otherwise it updates it.
            <para>
            If the primary key is assigned, then you must invoke <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Create"/>
            or <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Update"/> instead.
            </para>
            </summary>
            <param name="instance">The ActiveRecord instance to be saved</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.SaveCopy(System.Object)">
            <summary>
            Saves a copy of the instance to the database. If the primary key is unitialized
            it creates the instance on the database. Otherwise it updates it.
            <para>
            If the primary key is assigned, then you must invoke <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Create"/>
            or <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Update"/> instead.
            </para>
            </summary>
            <param name="instance">The transient instance to be saved</param>
            <returns>The saved ActiveRecord instance</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.SaveCopyAndFlush(System.Object)">
            <summary>
            Saves a copy of the instance to the database and flushes the session. If the primary key is unitialized
            it creates the instance on the database. Otherwise it updates it.
            <para>
            If the primary key is assigned, then you must invoke <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Create"/>
            or <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Update"/> instead.
            </para>
            </summary>
            <param name="instance">The transient instance to be saved</param>
            <returns>The saved ActiveRecord instance</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.InternalSave(System.Object,System.Boolean)">
            <summary>
            Saves the instance to the database. If the primary key is unitialized
            it creates the instance on the database. Otherwise it updates it.
            <para>
            If the primary key is assigned, then you must invoke <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Create"/>
            or <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Update"/> instead.
            </para>
            </summary>
            <param name="instance">The ActiveRecord instance to be saved</param>
            <param name="flush">if set to <c>true</c>, the operation will be followed by a session flush.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.InternalSaveCopy(System.Object,System.Boolean)">
            <summary>
            Saves a copy of the instance to the database. If the primary key is unitialized
            it creates the instance on the database. Otherwise it updates it.
            <para>
            If the primary key is assigned, then you must invoke <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Create"/>
            or <see cref="M:Castle.ActiveRecord.ActiveRecordBase.Update"/> instead.
            </para>
            </summary>
            <param name="instance">The transient instance to be saved</param>
            <param name="flush">if set to <c>true</c>, the operation will be followed by a session flush.</param>
            <returns>The saved ActiveRecord instance.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Execute(System.Type,Castle.ActiveRecord.NHibernateDelegate,System.Object)">
            <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
            <param name="targetType">The target ActiveRecordType</param>
            <param name="call">The delegate instance</param>
            <param name="instance">The ActiveRecord instance</param>
            <returns>Whatever is returned by the delegate invocation</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.EnumerateQuery(Castle.ActiveRecord.IActiveRecordQuery)">
            <summary>
            Enumerates the query
            Note: only use if you expect most of the values to exist on the second level cache.
            </summary>
            <param name="query">The query.</param>
            <returns>An <see cref="T:System.Collections.IEnumerable"/></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.ExecuteQuery(Castle.ActiveRecord.IActiveRecordQuery)">
            <summary>
            Executes the query.
            </summary>
            <param name="query">The query.</param>
            <returns>The query result.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Count(System.Type)">
            <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
            <example>
            <code>
            [ActiveRecord]
            public class User : ActiveRecordBase
            {
              ...
              
              public static int CountAllUsers()
              {
                return Count(typeof(User));
              }
            }
            </code>
            </example>
            <param name="targetType">The target type.</param>
            <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Count(System.Type,System.String,System.Object[])">
            <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
            <example>
            <code>
            [ActiveRecord]
            public class User : ActiveRecordBase
            {
              ...
              
              public static int CountAllUsersLocked()
              {
                return Count(typeof(User), "IsLocked = ?", true);
              }
            }
            </code>
            </example>
            <param name="targetType">The target type.</param>
            <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
            <param name="args">Positional parameters for the filter string</param>
            <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Count(System.Type,NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
            <param name="targetType">The target type.</param>
            <param name="criteria">The criteria expression</param>
            <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Count(System.Type,NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
            <param name="targetType">The target type.</param>
            <param name="detachedCriteria">The criteria expression</param>
            <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Exists(System.Type)">
            <summary>
            Check if there is any records in the db for the target type
            </summary>
            <param name="targetType">The target type.</param>
            <returns><c>true</c> if there's at least one row</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Exists(System.Type,System.String,System.Object[])">
            <summary>
            Check if there is any records in the db for the target type
            </summary>
            <param name="targetType">The target type.</param>
            <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
            <param name="args">Positional parameters for the filter string</param>
            <returns><c>true</c> if there's at least one row</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Exists(System.Type,System.Object)">
            <summary>
            Check if the <paramref name="id"/> exists in the database.
            </summary>
            <param name="targetType">The target type.</param>
            <param name="id">The id to check on</param>
            <returns><c>true</c> if the ID exists; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Exists(System.Type,NHibernate.Criterion.ICriterion[])">
            <summary>
            Check if any instance matching the criteria exists in the database.
            </summary>
            <param name="targetType">The target type.</param>
            <param name="criteria">The criteria expression</param>		
            <returns><c>true</c> if an instance is found; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Exists(System.Type,NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Check if any instance matching the criteria exists in the database.
            </summary>
            <param name="targetType">The target type.</param>
            <param name="detachedCriteria">The criteria expression</param>		
            <returns><c>true</c> if an instance is found; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Exists(System.Type,NHibernate.IDetachedQuery)">
            <summary>
            Check if there is any records in the db for the target type
            </summary>
            <param name="targetType">The target type.</param>
            <param name="detachedQuery"></param>
            <returns><c>true</c> if there's at least one row</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAll(System.Type,NHibernate.Criterion.DetachedCriteria,NHibernate.Criterion.Order[])">
            <summary>
            Returns all instances found for the specified type according to the criteria
            </summary>
            <param name="targetType">The target type.</param>
            <param name="detachedCriteria">The criteria.</param>
            <param name="orders">An <see cref="T:System.Array"/> of <see cref="T:NHibernate.Criterion.Order"/> objects.</param>
            <returns>The <see cref="T:System.Array"/> of results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAll(System.Type)">
            <summary>
            Returns all instances found for the specified type.
            </summary>
            <param name="targetType">The target type.</param>
            <returns>The <see cref="T:System.Array"/> of results</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAll(System.Type,NHibernate.Criterion.Order[],NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using sort orders and criteria.
            </summary>
            <param name="targetType">The The target type.</param>
            <param name="orders">An <see cref="T:System.Array"/> of <see cref="T:NHibernate.Criterion.Order"/> objects.</param>
            <param name="criteria">The criteria expression</param>
            <returns>The <see cref="T:System.Array"/> of results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAll(System.Type,NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using criteria.
            </summary>
            <param name="targetType">The target type.</param>
            <param name="criteria">The criteria expression</param>
            <returns>The <see cref="T:System.Array"/> of results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAll(System.Type,NHibernate.IDetachedQuery)">
            <summary>
            Returns all instances found for the specified type according to the criteria
            </summary>
            <param name="targetType">The target type.</param>
            <param name="detachedQuery">The query expression</param>
            <returns>The <see cref="T:System.Array"/> of results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAllByProperty(System.Type,System.String,System.Object)">
            <summary>
            Finds records based on a property value - automatically converts null values to IS NULL style queries. 
            </summary>
            <param name="targetType">The target type</param>
            <param name="property">A property name (not a column name)</param>
            <param name="value">The value to be equals to</param>
            <returns>The <see cref="T:System.Array"/> of results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindAllByProperty(System.Type,System.String,System.String,System.Object)">
            <summary>
            Finds records based on a property value - automatically converts null values to IS NULL style queries. 
            </summary>
            <param name="targetType">The target type</param>
            <param name="orderByColumn">The column name to be ordered ASC</param>
            <param name="property">A property name (not a column name)</param>
            <param name="value">The value to be equals to</param>
            <returns>The <see cref="T:System.Array"/> of results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindByPrimaryKey(System.Type,System.Object)">
            <summary>
            Finds an object instance by an unique ID
            </summary>
            <param name="targetType">The AR subclass type</param>
            <param name="id">ID value</param>
            <returns>The object instance.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindByPrimaryKey(System.Type,System.Object,System.Boolean)">
            <summary>
            Finds an object instance by an unique ID
            </summary>
            <param name="targetType">The AR subclass type</param>
            <param name="id">ID value</param>
            <param name="throwOnNotFound"><c>true</c> if you want to catch an exception 
            if the object is not found</param>
            <returns>The object instance.</returns>
            <exception cref="T:NHibernate.ObjectNotFoundException">if <c>throwOnNotFound</c> is set to 
            <c>true</c> and the row is not found</exception>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindFirst(System.Type,NHibernate.Criterion.DetachedCriteria,NHibernate.Criterion.Order[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="targetType">The target type.</param>
            <param name="detachedCriteria">The criteria.</param>
            <param name="orders">The sort order - used to determine which record is the first one.</param>
            <returns>A <c>targetType</c> instance or <c>null.</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindFirst(System.Type,NHibernate.Criterion.Order[],NHibernate.Criterion.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="targetType">The target type</param>
            <param name="orders">The sort order - used to determine which record is the first one</param>
            <param name="criteria">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindFirst(System.Type,NHibernate.Criterion.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="targetType">The target type</param>
            <param name="criteria">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindFirst(System.Type,NHibernate.IDetachedQuery)">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="targetType">The target type.</param>
            <param name="detachedQuery">The expression query.</param>
            <returns>A <c>targetType</c> instance or <c>null.</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindOne(System.Type,NHibernate.Criterion.ICriterion[])">
            <summary>
            Searches and returns a row. If more than one is found, 
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/>
            </summary>
            <param name="targetType">The target type</param>
            <param name="criteria">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindOne(System.Type,NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Searches and returns a row. If more than one is found, 
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/>
            </summary>
            <param name="targetType">The target type</param>
            <param name="criteria">The criteria</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.FindOne(System.Type,NHibernate.IDetachedQuery)">
            <summary>
            Searches and returns a row. If more than one is found,
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/>
            </summary>
            <param name="targetType">The target type</param>
            <param name="detachedQuery">The query expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Criterion.Order[],NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
            <param name="targetType">The target type.</param>
            <param name="firstResult">The number of the first row to retrieve.</param>
            <param name="maxResults">The maximum number of results retrieved.</param>
            <param name="orders">An <see cref="T:System.Array"/> of <see cref="T:NHibernate.Criterion.Order"/> objects.</param>
            <param name="criteria">The criteria expression</param>
            <returns>The sliced query results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Criterion.Order[],NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
            <param name="targetType">The target type.</param>
            <param name="firstResult">The number of the first row to retrieve.</param>
            <param name="maxResults">The maximum number of results retrieved.</param>
            <param name="orders">An <see cref="T:System.Array"/> of <see cref="T:NHibernate.Criterion.Order"/> objects.</param>
            <param name="criteria">The criteria expression</param>
            <returns>The sliced query results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
            <param name="targetType">The target type.</param>
            <param name="firstResult">The number of the first row to retrieve.</param>
            <param name="maxResults">The maximum number of results retrieved.</param>
            <param name="criteria">The criteria expression</param>
            <returns>The sliced query results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
            <param name="targetType">The target type.</param>
            <param name="firstResult">The number of the first row to retrieve.</param>
            <param name="maxResults">The maximum number of results retrieved.</param>
            <param name="criteria">The criteria expression</param>
            <returns>The sliced query results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.IDetachedQuery)">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
            <param name="targetType">The target type.</param>
            <param name="firstResult">The number of the first row to retrieve.</param>
            <param name="maxResults">The maximum number of results retrieved.</param>
            <param name="detachedQuery">The query expression</param>
            <returns>The sliced query results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Execute(Castle.ActiveRecord.NHibernateDelegate)">
            <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
            <param name="call">The delegate instance</param>
            <returns>Whatever is returned by the delegate invocation</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Save">
            <summary>
            Saves the instance information to the database.
            May Create or Update the instance depending 
            on whether it has a valid ID.
            </summary>
            <remarks>
            If within a <see cref="T:Castle.ActiveRecord.SessionScope"/> the operation
            is going to be on hold until NHibernate (or you) decides to flush
            the session.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.SaveAndFlush">
            <summary>
            Saves the instance information to the database.
            May Create or Update the instance depending 
            on whether it has a valid ID.
            </summary>
            <remarks>
            Even within a <see cref="T:Castle.ActiveRecord.SessionScope"/> the operation
            is going to be flushed immediately. This might have side effects such as
            flushing (persisting) others operations that were on hold.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.SaveCopy">
            <summary>
            Saves a copy of the instance information to the database.
            May Create or Update the instance depending 
            on whether it has a valid ID.
            </summary>
            <returns>An saved ActiveRecord instance</returns>
            <remarks>
            If within a <see cref="T:Castle.ActiveRecord.SessionScope"/> the operation
            is going to be on hold until NHibernate (or you) decides to flush
            the session.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.SaveCopyAndFlush">
            <summary>
            Saves a copy of the instance information to the database.
            May Create or Update the instance depending 
            on whether it has a valid ID.
            </summary>
            <returns>A saved ActiveRecord instance</returns>
            <remarks>
            Even within a <see cref="T:Castle.ActiveRecord.SessionScope"/> the operation
            is going to be flushed immediately. This might have side effects such as
            flushing (persisting) others operations that were on hold.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Create">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
            <remarks>
            If within a <see cref="T:Castle.ActiveRecord.SessionScope"/> the operation
            is going to be on hold until NHibernate (or you) decides to flush
            the session.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.CreateAndFlush">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
            <remarks>
            Even within a <see cref="T:Castle.ActiveRecord.SessionScope"/> the operation
            is going to be flushed immediately. This might have side effects such as
            flushing (persisting) others operations that were on hold.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Update">
            <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
            <remarks>
            If within a <see cref="T:Castle.ActiveRecord.SessionScope"/> the operation
            is going to be on hold until NHibernate (or you) decides to flush
            the session.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.UpdateAndFlush">
            <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
            <remarks>
            Even within a <see cref="T:Castle.ActiveRecord.SessionScope"/> the operation
            is going to be flushed immediately. This might have side effects such as
            flushing (persisting) others operations that were on hold.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Delete">
            <summary>
            Deletes the instance from the database.
            </summary>
            <remarks>
            If within a <see cref="T:Castle.ActiveRecord.SessionScope"/> the operation
            is going to be on hold until NHibernate (or you) decides to flush
            the session.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.DeleteAndFlush">
            <summary>
            Deletes the instance from the database.
            </summary>
            <remarks>
            Even within a <see cref="T:Castle.ActiveRecord.SessionScope"/> the operation
            is going to be flushed immediately. This might have side effects such as
            flushing (persisting) others operations that were on hold.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Refresh">
            <summary>
            Refresh the instance from the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.ToString">
            <summary>
            Return the type of the object with its PK value.
            Useful for logging/debugging
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Asc(System.String[])">
            <summary>
            Ascending Order
            </summary>
            <remarks>
            Returns an array of Ascending <see cref="T:NHibernate.Criterion.Order"/> instances specifing which properties to use to 
            order a result.
            </remarks>
            <param name="propertyNames">List of property names to order by ascending</param>
            <returns>Array of <see cref="T:NHibernate.Criterion.Order"/> objects suitable for passing to FindAll and variants</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase.Desc(System.String[])">
            <summary>
            Descending Order
            </summary>
            <remarks>
            Returns an array of Descending <see cref="T:NHibernate.Criterion.Order"/> instances specifing which properties to use to 
            order a result.
            </remarks>
            <param name="propertyNames">List of property names to order by descending</param>
            <returns>Array of <see cref="T:NHibernate.Criterion.Order"/> objects suitable for passing to FindAll and variants</returns>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordBase`1">
            <summary>
            Base class for all ActiveRecord Generic classes. 
            Implements all the functionality to simplify the code on the subclasses.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Create(`0)">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
            <param name="instance">The ActiveRecord instance to be created on the database</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Delete(`0)">
            <summary>
            Deletes the instance from the database.
            </summary>
            <param name="instance">The ActiveRecord instance to be deleted</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.DeleteAll">
            <summary>
            Deletes all rows for the specified ActiveRecord type
            </summary>
            <remarks>
            This method is usually useful for test cases.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.DeleteAll(System.String)">
            <summary>
            Deletes all rows for the specified ActiveRecord type that matches
            the supplied HQL condition
            </summary>
            <remarks>
            This method is usually useful for test cases.
            </remarks>
            <param name="where">HQL condition to select the rows to be deleted</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.DeleteAll(System.Collections.IEnumerable)">
            <summary>
            Deletes all <typeparamref name="T"/> objects, based on the primary keys
            supplied on <paramref name="pkValues" />.
            </summary>
            <returns>The number of objects deleted</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Refresh(`0)">
            <summary>
            Refresh the instance from the database.
            </summary>
            <param name="instance">The ActiveRecord instance to be reloaded</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Update(`0)">
            <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
            <param name="instance">The ActiveRecord instance to be updated on the database</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Save(`0)">
            <summary>
            Saves the instance to the database. If the primary key is unitialized
            it creates the instance on the database. Otherwise it updates it.
            <para>
            If the primary key is assigned, then you must invoke <see cref="M:Castle.ActiveRecord.ActiveRecordBase`1.Create(`0)"/>
            or <see cref="M:Castle.ActiveRecord.ActiveRecordBase`1.Update(`0)"/> instead.
            </para>
            </summary>
            <param name="instance">The ActiveRecord instance to be saved</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.SaveCopy(`0)">
            <summary>
            Saves a copy of the instance to the database. If the primary key is unitialized
            it creates the instance on the database. Otherwise it updates it.
            <para>
            If the primary key is assigned, then you must invoke <see cref="M:Castle.ActiveRecord.ActiveRecordBase`1.Create(`0)"/>
            or <see cref="M:Castle.ActiveRecord.ActiveRecordBase`1.Update(`0)"/> instead.
            </para>
            </summary>
            <param name="instance">The transient instance to be saved</param>
            <returns>The saved ActiveRecord instance.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Execute(Castle.ActiveRecord.NHibernateDelegate,System.Object)">
            <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
            <param name="call">The delegate instance</param>
            <param name="instance">The ActiveRecord instance</param>
            <returns>Whatever is returned by the delegate invocation</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.ExecuteQuery2``1(Castle.ActiveRecord.IActiveRecordQuery{``0})">
            <summary>
            Executes the query and return a strongly typed result
            </summary>
            <param name="query">The query.</param>
            <returns>The query result.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Count">
            <summary>
            Returns the number of records of <typeparamref name="T"/> in the database
            </summary>
            <example>
            <code escaped="true">
            [ActiveRecord]
            public class User : ActiveRecordBase&lt;User&gt;
            {
              ...
              
              public static int CountAllUsers()
              {
                return Count(); // Equivalent to: Count(typeof(User));
              }
            }
            </code>
            </example>
            <returns>The count query result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Count(System.String,System.Object[])">
            <summary>
            Returns the number of records of <typeparamref name="T"/> in the database
            </summary>
            <example>
            <code escaped="true">
            [ActiveRecord]
            public class User : ActiveRecordBase&lt;User&gt;
            {
              ...
              
              public static int CountAllUsersLocked()
              {
                return Count("IsLocked = ?", true); // Equivalent to: Count(typeof(User), "IsLocked = ?", true);
              }
            }
            </code>
            </example>
            <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
            <param name="args">Positional parameters for the filter string</param>
            <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Count(NHibernate.Criterion.ICriterion[])">
            <summary>
            Check if any instance matching the criteria exists in the database.
            </summary>
            <param name="criteria">The criteria expression</param>		
            <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Count(NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
            <param name="detachedCriteria">The criteria expression</param>
            <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Exists">
            <summary>
            Check if there is any records in the db for <typeparamref name="T"/>
            </summary>
            <returns><c>true</c> if there's at least one row</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Exists(System.String,System.Object[])">
            <summary>
            Check if there is any records in the db for <typeparamref name="T"/>
            </summary>
            <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
            <param name="args">Positional parameters for the filter string</param>
            <returns><c>true</c> if there's at least one row</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Exists``1(``0)">
            <summary>
            Check if the <paramref name="id"/> exists in the database.
            </summary>
            <typeparam name="PkType">The <c>System.Type</c> of the PrimaryKey</typeparam>
            <param name="id">The id to check on</param>
            <returns><c>true</c> if the ID exists; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Exists(NHibernate.Criterion.ICriterion[])">
            <summary>
            Check if any instance matching the criteria exists in the database.
            </summary>
            <param name="criteria">The criteria expression</param>		
            <returns><c>true</c> if an instance is found; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Exists(NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Check if any instance matching the criteria exists in the database.
            </summary>
            <param name="detachedCriteria">The criteria expression</param>		
            <returns><c>true</c> if an instance is found; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Exists(NHibernate.IDetachedQuery)">
            <summary>
            Check if any instance matching the query exists in the database.
            </summary>
            <param name="detachedQuery">The query expression</param>
            <returns>true if an instance is found; otherwise false.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAll(NHibernate.Criterion.DetachedCriteria,NHibernate.Criterion.Order[])">
            <summary>
            Returns all the instances that match the detached criteria.
            </summary>
            <param name="criteria">Detached criteria</param>
            <param name="orders">Optional ordering</param>
            <returns>All entities that match the criteria</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAll">
            <summary>
            Returns all instances found for <typeparamref name="T"/>
            </summary>
            <returns>An <see cref="T:System.Array"/> of <typeparamref name="T"/></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAll(NHibernate.Criterion.Order,NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using sort orders and criteria.
            </summary>
            <param name="order">An <see cref="T:NHibernate.Criterion.Order"/> object.</param>
            <param name="criteria">The criteria expression</param>
            <returns>The <see cref="T:System.Array"/> of results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAll(NHibernate.Criterion.Order[],NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns all instances found for <typeparamref name="T"/>
            using sort orders and criteria.
            </summary>
            <param name="orders"></param>
            <param name="criteria"></param>
            <returns>An <see cref="T:System.Array"/> of <typeparamref name="T"/></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAll(NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns all instances found for <typeparamref name="T"/>
            using criteria.
            </summary>
            <param name="criteria"></param>
            <returns>An <see cref="T:System.Array"/> of <typeparamref name="T"/></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAll(NHibernate.IDetachedQuery)">
            <summary>
            Returns all instances found for the specified type according to the criteria
            </summary>
            <param name="detachedQuery">The query expression.</param>
            <returns>All entities that match the query</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAllByProperty(System.String,System.Object)">
            <summary>
            Finds records based on a property value
            </summary>
            <param name="property">A property name (not a column name)</param>
            <param name="value">The value to be equals to</param>
            <returns>An <see cref="T:System.Array"/> of <typeparamref name="T"/></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindAllByProperty(System.String,System.String,System.Object)">
            <summary>
            Finds records based on a property value
            </summary>
            <param name="orderByColumn">The column name to be ordered ASC</param>
            <param name="property">A property name (not a column name)</param>
            <param name="value">The value to be equals to</param>
            <returns>An <see cref="T:System.Array"/> of <typeparamref name="T"/></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.Find(System.Object)">
            <summary>
            Finds an object instance by an unique ID 
            </summary>
            <param name="id">ID value</param>
            <exception cref="T:NHibernate.ObjectNotFoundException">if the row is not found</exception>
            <returns>T</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.TryFind(System.Object)">
            <summary>
            Finds an object instance by an unique ID.
            If the row is not found this method will not throw an exception.
            </summary>
            <param name="id">ID value</param>
            <returns>A <typeparamref name="T"/></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindByPrimaryKey(System.Object)">
            <summary>
            Finds an object instance by an unique ID for <typeparamref name="T"/>
            </summary>
            <param name="id">ID value</param>
            <returns>A <typeparamref name="T"/></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindByPrimaryKey(System.Object,System.Boolean)">
            <summary>
            Finds an object instance by a unique ID for <typeparamref name="T"/>
            </summary>
            <param name="id">ID value</param>
            <param name="throwOnNotFound"><c>true</c> if you want to catch an exception 
            if the object is not found</param>
            <returns>A <typeparamref name="T"/></returns>
            <exception cref="T:NHibernate.ObjectNotFoundException">if <c>throwOnNotFound</c> is set to 
            <c>true</c> and the row is not found</exception>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindFirst(NHibernate.Criterion.DetachedCriteria,NHibernate.Criterion.Order[])">
            <summary>
            Searches and returns the first row for <typeparamref name="T"/>.
            </summary>
            <param name="criteria">Detached criteria.</param>
            <param name="orders">The sort order - used to determine which record is the first one.</param>
            <returns>A <c>targetType</c> instance or <c>null</c>.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindFirst(NHibernate.Criterion.Order,NHibernate.Criterion.ICriterion[])">
            <summary>
            Searches and returns the first row for <typeparamref name="T"/>
            </summary>
            <param name="order">The sort order - used to determine which record is the first one</param>
            <param name="criteria">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindFirst(NHibernate.Criterion.Order[],NHibernate.Criterion.ICriterion[])">
            <summary>
            Searches and returns the first row for <typeparamref name="T"/>
            </summary>
            <param name="orders">The sort order - used to determine which record is the first one</param>
            <param name="criteria">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindFirst(NHibernate.Criterion.ICriterion[])">
            <summary>
            Searches and returns the first row for <typeparamref name="T"/>
            </summary>
            <param name="criteria">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindFirst(NHibernate.IDetachedQuery)">
            <summary>
            Searches and returns the first row. 
            </summary>
            <param name="detachedQuery">The query expression</param>
            <returns>A <c>targetType</c> instance or <c>null.</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindOne(NHibernate.Criterion.ICriterion[])">
            <summary>
            Searches and returns a row. If more than one is found, 
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/>
            </summary>
            <param name="criteria">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindOne(NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Searches and returns a row. If more than one is found, 
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/>
            </summary>
            <param name="criteria">The criteria</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.FindOne(NHibernate.IDetachedQuery)">
            <summary>
            Searches and returns a row. If more than one is found, 
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/>
            <param name="detachedQuery">The query expression</param>
            </summary>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.Criterion.Order[],NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
            <param name="firstResult">The number of the first row to retrieve.</param>
            <param name="maxResults">The maximum number of results retrieved.</param>
            <param name="orders">An <see cref="T:System.Array"/> of <see cref="T:NHibernate.Criterion.Order"/> objects.</param>
            <param name="criteria">The criteria expression</param>
            <returns>The sliced query results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
            <param name="firstResult">The number of the first row to retrieve.</param>
            <param name="maxResults">The maximum number of results retrieved.</param>
            <param name="criteria">The criteria expression</param>
            <returns>The sliced query results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.Criterion.DetachedCriteria,NHibernate.Criterion.Order[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
            <param name="firstResult">The number of the first row to retrieve.</param>
            <param name="maxResults">The maximum number of results retrieved.</param>
            <param name="orders">An <see cref="T:System.Array"/> of <see cref="T:NHibernate.Criterion.Order"/> objects.</param>
            <param name="criteria">The criteria expression</param>
            <returns>The sliced query results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordBase`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.IDetachedQuery)">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
            <param name="firstResult">The number of the first row to retrieve.</param>
            <param name="maxResults">The maximum number of results retrieved.</param>
            <returns>The sliced query results.</returns>
            <param name="detachedQuery">The query expression</param>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.ActiveRecordException">
            <summary>
            This exception is raised when Active Record encounters a problem
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ActiveRecordException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ActiveRecordException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ActiveRecordException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"></see> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"></see> is zero (0). </exception>
            <exception cref="T:System.ArgumentNullException">The info parameter is null. </exception>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.ActiveRecordInitializationException">
            <summary>
            Exception thrown when an error is detected on the ActiveRecord initialization phase.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ActiveRecordInitializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordInitializationException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ActiveRecordInitializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordInitializationException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ActiveRecordInitializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordInitializationException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"></see> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"></see> is zero (0). </exception>
            <exception cref="T:System.ArgumentNullException">The info parameter is null. </exception>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordHooksValidationBase">
            <summary>
            Extends <see cref="T:Castle.ActiveRecord.ActiveRecordHooksBase"/> adding automatic validation support, 
            through implementing <see cref="T:Castle.ActiveRecord.Framework.IValidationProvider"/>.
            </summary>
            <example>
            <code>
            using Castle.Components.Validator;
            
            public class Customer : ActiveRecordHooksBase
            {
            	...
            	
            	[Property, ValidateNonEmpty]
            	public int Name
            	{
            		get { return _name; }
            		set { _name = value; }
            	}
            	
            	[Property, ValidateNonEmpty, ValidateEmail]
            	public int Email
            	{
            		get { return _email; }
            		set { _email = value; }
            	}
            </code>
            </example>
            <remarks>
            Uses an <see cref="T:Castle.ActiveRecord.Framework.IValidationProvider"/> internally to do the actual validation.
            </remarks>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.IValidationProvider">
            <summary>
            Indicates that something has validation support built in. 
            <para>
            For a concrete implementation, see <see cref="T:Castle.ActiveRecord.ActiveRecordValidator"/> and 
            <see cref="T:Castle.ActiveRecord.ActiveRecordHooksValidationBase"/>.
            ActiveRecordHooksValidationBase and ActiveRecordValidator both implement IHaveValidation.
            The hooks base uses a private IHaveValidation "ActualValidator" to do the actual validation.
            The default ActualValidator is a ActiveRecordValidator, but you can override this.
            </para>
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.IValidationProvider.IsValid">
            <summary>
            Performs the fields validation. Returns true if no 
            validation error was found.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.IValidationProvider.IsValid(Castle.Components.Validator.RunWhen)">
            <summary>
            Performs the fields validation for the specified action.
            </summary>
            <param name="runWhen">Use validators appropriate to the action being performed.</param>
            <returns>True if no validation error was found</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IValidationProvider.ValidationErrorMessages">
            <summary>
            Returns a list of current validation errors messages.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.IValidationProvider.PropertiesValidationErrorMessages">
            <summary>
            Maps a specific PropertyInfo to a list of
            error messages. Useful for frameworks.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.ActiveRecordHooksValidationBase._actualValidator">
            <summary>
            Field for <see cref="P:Castle.ActiveRecord.ActiveRecordHooksValidationBase.ActualValidator"/>.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksValidationBase.#ctor">
            <summary>
            Constructs an ActiveRecordHooksValidationBase
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksValidationBase.IsValid">
            <summary>
            Performs the fields validation. Returns true if no 
            validation error was found.
            </summary>
            <returns></returns>
            <remarks>Forwards the call to <see cref="P:Castle.ActiveRecord.ActiveRecordHooksValidationBase.ActualValidator"/>.</remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksValidationBase.IsValid(Castle.Components.Validator.RunWhen)">
            <summary>
            Performs the fields validation for the specified action.
            </summary>
            <param name="runWhen">Use validators appropriate to the action being performed.</param>
            <returns>True if no validation error was found</returns>
            <remarks>Forwards the call to <see cref="P:Castle.ActiveRecord.ActiveRecordHooksValidationBase.ActualValidator"/>.</remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksValidationBase.BeforeSave(System.Collections.IDictionary)">
            <summary>
            Override the base hook to call validators required for create.
            </summary>
            <param name="state">The current state of the object</param>
            <returns>Returns true if the state has changed otherwise false</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksValidationBase.OnFlushDirty(System.Object,System.Collections.IDictionary,System.Collections.IDictionary,NHibernate.Type.IType[])">
            <summary>
            Override the base hook to call validators required for update.
            </summary>
            <param name="id">object id</param>
            <param name="previousState">The previous state of the object</param>
            <param name="currentState">The current state of the object</param>
            <param name="types">Property types</param>
            <returns>Returns true if the state has changed otherwise false</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordHooksValidationBase.OnNotValid">
            <summary>
            Throws an exception explaining why the save or update
            cannot be executed when fields are not ok to pass.
            </summary>
            <remarks>
            You can override this method to declare a better behavior.
            </remarks>
            <remarks>Forwards the call to <see cref="P:Castle.ActiveRecord.ActiveRecordHooksValidationBase.ActualValidator"/>.</remarks>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordHooksValidationBase.ActualValidator">
            <summary>
            Gets the <see cref="T:Castle.ActiveRecord.Framework.IValidationProvider"/> that actually validates this AR object.
            Normally returns a <see cref="T:Castle.ActiveRecord.ActiveRecordValidator"/>, but you can override this
            to return a custom validator.
            </summary>
            <value>The validator.</value>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordHooksValidationBase.ValidationErrorMessages">
            <summary>
            Returns a list of current validation errors messages.
            </summary>
            <remarks>Forwards the call to <see cref="P:Castle.ActiveRecord.ActiveRecordHooksValidationBase.ActualValidator"/>.</remarks>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordHooksValidationBase.PropertiesValidationErrorMessages">
            <summary>
            Maps a specific PropertyInfo to a list of
            error messages. Useful for frameworks.
            </summary>
            <remarks>Forwards the call to <see cref="P:Castle.ActiveRecord.ActiveRecordHooksValidationBase.ActualValidator"/>.</remarks>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordMediator">
            <summary>
            Allow programmers to use the
            ActiveRecord functionality without direct reference
            to <see cref="T:Castle.ActiveRecord.ActiveRecordBase"/>
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Execute(System.Type,Castle.ActiveRecord.NHibernateDelegate,System.Object)">
            <summary>
            Invokes the specified delegate passing a valid
            NHibernate session. Used for custom NHibernate queries.
            </summary>
            <param name="targetType">The target ActiveRecordType</param>
            <param name="call">The delegate instance</param>
            <param name="instance">The ActiveRecord instance</param>
            <returns>Whatever is returned by the delegate invocation</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindByPrimaryKey(System.Type,System.Object,System.Boolean)">
            <summary>
            Finds an object instance by its primary key.
            </summary>
            <param name="targetType">The AR subclass type</param>
            <param name="id">ID value</param>
            <param name="throwOnNotFound"><c>true</c> if you want an exception to be thrown
            if the object is not found</param>
            <exception cref="T:NHibernate.ObjectNotFoundException">if <c>throwOnNotFound</c> is set to
            <c>true</c> and the row is not found</exception>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindByPrimaryKey(System.Type,System.Object)">
            <summary>
            Finds an object instance by its primary key.
            </summary>
            <param name="targetType">The AR subclass type</param>
            <param name="id">ID value</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindFirst(System.Type,NHibernate.Criterion.Order[],NHibernate.Criterion.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="targetType">The target type</param>
            <param name="orders">The sort order - used to determine which record is the first one</param>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindFirst(System.Type,NHibernate.Criterion.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="targetType">The target type</param>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindFirst(System.Type,NHibernate.Criterion.DetachedCriteria,NHibernate.Criterion.Order[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="targetType">The target type.</param>
            <param name="detachedCriteria">The criteria.</param>
            <param name="orders">The sort order - used to determine which record is the first one.</param>
            <returns>A <c>targetType</c> instance or <c>null.</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindFirst(System.Type,NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="targetType">The target type</param>
            <param name="criteria">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindFirst(System.Type,NHibernate.IDetachedQuery)">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="targetType">The target type.</param>
            <param name="detachedQuery">The expression query.</param>
            <returns>A <c>targetType</c> instance or <c>null.</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindOne(System.Type,NHibernate.Criterion.ICriterion[])">
            <summary>
            Searches and returns the a row. If more than one is found,
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/>
            </summary>
            <param name="targetType">The target type</param>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindOne(System.Type,NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Searches and returns a row. If more than one is found,
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/>
            </summary>
            <param name="targetType">The target type</param>
            <param name="criteria">The criteria</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindOne(System.Type,NHibernate.IDetachedQuery)">
            <summary>
            Searches and returns a row. If more than one is found,
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/>
            </summary>
            <param name="targetType">The target type</param>
            <param name="detachedQuery">The query expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Criterion.Order[],NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Criterion.Order[],NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SlicedFindAll(System.Type,System.Int32,System.Int32,NHibernate.IDetachedQuery)">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
            <param name="targetType">The target type.</param>
            <param name="firstResult">The number of the first row to retrieve.</param>
            <param name="maxResults">The maximum number of results retrieved.</param>
            <param name="detachedQuery">The query expression</param>
            <returns>The sliced query results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAll(System.Type)">
            <summary>
            Returns all instances found for the specified type.
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAll(System.Type,NHibernate.Criterion.Order[],NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns all instances found for the specified type
            using sort orders and criterias.
            </summary>
            <param name="targetType"></param>
            <param name="orders"></param>
            <param name="criterias"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAll(System.Type,NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns all instances found for the specified type
            using criterias.
            </summary>
            <param name="targetType"></param>
            <param name="criterias"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAll(System.Type,NHibernate.Criterion.DetachedCriteria,NHibernate.Criterion.Order[])">
            <summary>
            Returns all instances found for the specified type according to the criteria
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAll(System.Type,NHibernate.IDetachedQuery)">
            <summary>
            Returns all instances found for the specified type according to the criteria
            </summary>
            <param name="targetType">The target type.</param>
            <param name="detachedQuery">The query expression</param>
            <returns>The <see cref="T:System.Array"/> of results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAllByProperty(System.Type,System.String,System.Object)">
            <summary>
            Finds records based on a property value - automatically converts null values to IS NULL style queries.
            </summary>
            <param name="targetType">The target type</param>
            <param name="property">A property name (not a column name)</param>
            <param name="value">The value to be equals to</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.FindAllByProperty(System.Type,System.String,System.String,System.Object)">
            <summary>
            Finds records based on a property value - automatically converts null values to IS NULL style queries.
            </summary>
            <param name="targetType">The target type</param>
            <param name="orderByColumn">The column name to be ordered ASC</param>
            <param name="property">A property name (not a column name)</param>
            <param name="value">The value to be equals to</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.DeleteAll(System.Type)">
            <summary>
            Deletes all entities of the specified type (and their inheritors)
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.DeleteAll(System.Type,System.String)">
            <summary>
            Deletes all entities of specified type that match the HQL where clause
            </summary>
            <param name="type">The type.</param>
            <param name="where">The where.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.DeleteAll(System.Type,System.Collections.IEnumerable)">
            <summary>
            Deletes all <paramref name="targetType" /> objects, based on the primary keys
            supplied on <paramref name="pkValues" />.
            </summary>
            <param name="targetType">The target ActiveRecord type</param>
            <param name="pkValues">A list of primary keys</param>
            <returns>The number of objects deleted</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.EnumerateQuery(Castle.ActiveRecord.IActiveRecordQuery)">
            <summary>
            Enumerates the query.
            Note: Only use if you expect most of the values to be on the second level cache
            </summary>
            <param name="q">The query</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.ExecuteQuery(Castle.ActiveRecord.IActiveRecordQuery)">
            <summary>
            Executes the query
            </summary>
            <param name="q">The query</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Count(System.Type)">
             <summary>
             Returns the number of records of the specified
             type in the database
             </summary>
             <example>
             <code>
             [ActiveRecord]
             public class User : ActiveRecordBase
             {
               ...
            
               public static int CountUsers()
               {
                 return Count(typeof(User));
               }
             }
             </code>
             </example>
             <param name="targetType">Type of the target.</param>
             <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Count(System.Type,System.String,System.Object[])">
             <summary>
             Returns the number of records of the specified
             type in the database
             </summary>
             <example>
             <code>
             [ActiveRecord]
             public class User : ActiveRecordBase
             {
               ...
            
               public static int CountUsersLocked()
               {
                 return Count(typeof(User), "IsLocked = ?", true);
               }
             }
             </code>
             </example>
             <param name="targetType">Type of the target.</param>
             <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
             <param name="args">Positional parameters for the filter string</param>
             <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Count(System.Type,NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns the number of records of the specified
            type in the database
            </summary>
            <param name="targetType">The target type.</param>
            <param name="criteria">The criteria expression</param>
            <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Count(System.Type,NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Returns the number of records of the specified
            type in the database
            </summary>
            <param name="targetType">The target type.</param>
            <param name="detachedCriteria">The criteria expression</param>
            <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Exists(System.Type)">
            <summary>
            Check if there is any records in the db for the target type
            </summary>
            <param name="targetType">Type of the target.</param>
            <returns><c>true</c> if there's at least one row</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Exists(System.Type,System.String,System.Object[])">
            <summary>
            Check if there is any records in the db for the target type
            </summary>
            <param name="targetType">Type of the target.</param>
            <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
            <param name="args">Positional parameters for the filter string</param>
            <returns><c>true</c> if there's at least one row</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Exists(System.Type,System.Object)">
            <summary>
            Check if the <paramref name="id"/> exists in the database.
            </summary>
            <param name="targetType">Type of the target.</param>
            <param name="id">The id to check on</param>
            <returns><c>true</c> if the ID exists; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Exists(System.Type,NHibernate.Criterion.ICriterion[])">
            <summary>
            Check if any instance matches the criteria.
            </summary>
            <returns><c>true</c> if an instance is found; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Exists(System.Type,NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Check if any instance matching the criteria exists in the database.
            </summary>
            <param name="targetType">The target type.</param>
            <param name="detachedCriteria">The criteria expression</param>
            <returns><c>true</c> if an instance is found; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Exists(System.Type,NHibernate.IDetachedQuery)">
            <summary>
            Check if any instance matches the query.
            </summary>
            <param name="targetType">target Type</param>
            <param name="detachedQuery">The query expression</param>
            <returns><c>true</c> if an instance is found; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Save(System.Object)">
            <summary>
            Saves the instance to the database
            </summary>
            <param name="instance">The ActiveRecord instance to be deleted</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SaveAndFlush(System.Object)">
            <summary>
            Saves the instance to the database and flushes the session. If the primary key is unitialized
            it creates the instance on the database. Otherwise it updates it.
            <para>
            If the primary key is assigned, then you must invoke <see cref="M:Castle.ActiveRecord.ActiveRecordMediator.Create(System.Object)"/>
            or <see cref="M:Castle.ActiveRecord.ActiveRecordMediator.Update(System.Object)"/> instead.
            </para>
            </summary>
            <param name="instance">The ActiveRecord instance to be saved</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SaveCopy(System.Object)">
            <summary>
            Saves a copy of instance to the database
            </summary>
            <param name="instance">The transient instance to be copied</param>
            <returns>The saved ActiveRecord instance</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.SaveCopyAndFlush(System.Object)">
            <summary>
            Saves a copy of the instance to the database and flushes the session. If the primary key is unitialized
            it creates the instance on the database. Otherwise it updates it.
            <para>
            If the primary key is assigned, then you must invoke <see cref="M:Castle.ActiveRecord.ActiveRecordMediator.Create(System.Object)"/>
            or <see cref="M:Castle.ActiveRecord.ActiveRecordMediator.Update(System.Object)"/> instead.
            </para>
            </summary>
            <param name="instance">The transient instance to be copied</param>
            <returns>The saved ActiveRecord instance</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Create(System.Object)">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
            <param name="instance">The ActiveRecord instance to be deleted</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.CreateAndFlush(System.Object)">
            <summary>
            Creates (Saves) a new instance to the database and flushes the session.
            </summary>
            <param name="instance">The ActiveRecord instance to be created on the database</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Update(System.Object)">
            <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
            <param name="instance">The ActiveRecord instance to be deleted</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.UpdateAndFlush(System.Object)">
            <summary>
            Persists the modification on the instance
            state to the database and flushes the session.
            </summary>
            <param name="instance">The ActiveRecord instance to be updated on the database</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Delete(System.Object)">
            <summary>
            Deletes the instance from the database.
            </summary>
            <param name="instance">The ActiveRecord instance to be deleted</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.DeleteAndFlush(System.Object)">
            <summary>
            Deletes the instance from the database and flushes the session.
            </summary>
            <param name="instance">The ActiveRecord instance to be deleted</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Refresh(System.Object)">
            <summary>
            Refresh the instance from the database.
            </summary>
            <param name="instance">The ActiveRecord instance to be reloaded</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.GetSessionFactoryHolder">
            <summary>
            Testing hock only.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Replicate(System.Object,NHibernate.ReplicationMode)">
            <summary>
            From NHibernate documentation:
            Persist all reachable transient objects, reusing the current identifier
            values. Note that this will not trigger the Interceptor of the Session.
            </summary>
            <param name="instance">The instance.</param>
            <param name="replicationMode">The replication mode.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.Evict(System.Object)">
            <summary>
            Evicts the specified instance from the first level cache (session level).
            </summary>
            <param name="instance">The instance.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.GlobalEvict(System.Type)">
            <summary>
            Evicts the specified type.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.GlobalEvict(System.Type,System.Object)">
            <summary>
            Evicts the specified type.
            </summary>
            <param name="type">The type.</param>
            <param name="id">The id.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.EvictEntity(System.String)">
            <summary> 
            From NH docs: Evict all entries from the second-level cache. This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy. Use with care.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.EvictCollection(System.String)">
            <summary>
            From NH docs: Evict all entries from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
            <param name="roleName">Name of the role.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.EvictCollection(System.String,System.Object)">
            <summary>
            From NH docs: Evict an entry from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
            <param name="roleName">Name of the role.</param>
            <param name="id">The id.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator.EvictQueries(System.String)">
            <summary>
            From NH docs: Evict any query result sets cached in the named query cache region.
            </summary>
            <param name="cacheRegion">The cache region.</param>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordMediator`1">
            <summary>
            Allow programmers to use the 
            ActiveRecord functionality without extending <see cref="T:Castle.ActiveRecord.ActiveRecordBase"/>
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Execute(Castle.ActiveRecord.NHibernateDelegate,`0)">
            <summary>
            Invokes the specified delegate passing a valid 
            NHibernate session. Used for custom NHibernate queries.
            </summary>
            <param name="call">The delegate instance</param>
            <param name="instance">The ActiveRecord instance</param>
            <returns>Whatever is returned by the delegate invocation</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindByPrimaryKey(System.Object,System.Boolean)">
            <summary>
            Finds an object instance by its primary key.
            </summary>
            <param name="id">ID value</param>
            <param name="throwOnNotFound"><c>true</c> if you want an exception to be thrown
            if the object is not found</param>
            <exception cref="T:NHibernate.ObjectNotFoundException">if <c>throwOnNotFound</c> is set to 
            <c>true</c> and the row is not found</exception>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindByPrimaryKey(System.Object)">
            <summary>
            Finds an object instance by its primary key.
            </summary>
            <param name="id">ID value</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindFirst(NHibernate.Criterion.Order[],NHibernate.Criterion.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="orders">The sort order - used to determine which record is the first one</param>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindFirst(NHibernate.Criterion.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="criterias">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindFirst(NHibernate.Criterion.DetachedCriteria,NHibernate.Criterion.Order[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="detachedCriteria">The criteria.</param>
            <param name="orders">The sort order - used to determine which record is the first one.</param>
            <returns>A <c>targetType</c> instance or <c>null.</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindFirst(NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="criteria">The criteria expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindFirst(NHibernate.IDetachedQuery)">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="detachedQuery">The expression query.</param>
            <returns>A <c>targetType</c> instance or <c>null.</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindOne(NHibernate.Criterion.ICriterion[])">
            <summary>
            Searches and returns the first row.
            </summary>
            <param name="criterias">The criterias.</param>
            <returns>A instance the targetType or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindOne(NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Searches and returns a row. If more than one is found, 
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/>
            </summary>
            <param name="criteria">The criteria</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindOne(NHibernate.IDetachedQuery)">
            <summary>
            Searches and returns a row. If more than one is found,
            throws <see cref="T:Castle.ActiveRecord.Framework.ActiveRecordException"/>
            </summary>
            <param name="detachedQuery">The query expression</param>
            <returns>A <c>targetType</c> instance or <c>null</c></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindAllByProperty(System.String,System.Object)">
            <summary>
            Finds records based on a property value - automatically converts null values to IS NULL style queries. 
            </summary>
            <param name="property">A property name (not a column name)</param>
            <param name="value">The value to be equals to</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindAllByProperty(System.String,System.String,System.Object)">
            <summary>
            Finds records based on a property value - automatically converts null values to IS NULL style queries. 
            </summary>
            <param name="orderByColumn">The column name to be ordered ASC</param>
            <param name="property">A property name (not a column name)</param>
            <param name="value">The value to be equals to</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindAll">
            <summary>
            Returns all instances found for the specified type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindAll(NHibernate.Criterion.Order[],NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using sort orders and criterias.
            </summary>
            <param name="orders"></param>
            <param name="criterias"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindAll(NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns all instances found for the specified type 
            using criterias.
            </summary>
            <param name="criterias"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindAll(NHibernate.Criterion.DetachedCriteria,NHibernate.Criterion.Order[])">
            <summary>
            Returns all instances found for the specified type according to the criteria
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.FindAll(NHibernate.IDetachedQuery)">
            <summary>
            Returns all instances found for the specified type according to the criteria
            </summary>
            <param name="detachedQuery">The query expression</param>
            <returns>The <see cref="T:System.Array"/> of results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.Criterion.Order[],NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.Criterion.DetachedCriteria,NHibernate.Criterion.Order[])">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.SlicedFindAll(System.Int32,System.Int32,NHibernate.IDetachedQuery)">
            <summary>
            Returns a portion of the query results (sliced)
            </summary>
            <param name="firstResult">The number of the first row to retrieve.</param>
            <param name="maxResults">The maximum number of results retrieved.</param>
            <param name="detachedQuery">The query expression</param>
            <returns>The sliced query results.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.DeleteAll">
            <summary>
            Deletes all entities of <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.DeleteAll(System.String)">
            <summary>
            Deletes all entities of <typeparamref name="T"/> that match the HQL where clause.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Save(`0)">
            <summary>
            Saves the instance to the database
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.SaveCopy(`0)">
            <summary>
            Saves a copy of the instance to the database
            </summary>
            <param name="instance"></param>
            <returns>The saved instance</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Create(`0)">
            <summary>
            Creates (Saves) a new instance to the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Update(`0)">
            <summary>
            Persists the modification on the instance
            state to the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Delete(`0)">
            <summary>
            Deletes the instance from the database.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Refresh(`0)">
            <summary>
            Refresh the instance from the database.
            </summary>
            <param name="instance">The ActiveRecord instance to be reloaded</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.ExecuteQuery2``1(Castle.ActiveRecord.IActiveRecordQuery{``0})">
            <summary>
            Executes the query and return a strongly typed result
            </summary>
            <param name="query">The query.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Exists``1(``0)">
            <summary>
            Check if the <paramref name="id"/> exists in the database.
            </summary>
            <typeparam name="PkType">The <c>System.Type</c> of the PrimaryKey</typeparam>
            <param name="id">The id to check on</param>
            <returns><c>true</c> if the ID exists; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Exists(NHibernate.IDetachedQuery)">
            <summary>
            Check if any instance matches the query.
            </summary>
            <param name="detachedQuery">The query expression</param>
            <returns><c>true</c> if an instance is found; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Count">
            <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
            <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Count(NHibernate.Criterion.ICriterion[])">
            <summary>
            Returns the number of records of the specified 
            type in the database that match the given critera
            </summary>
            <param name="criteria">The criteria expression</param>
            <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Count(System.String,System.Object[])">
            <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
            <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
            <param name="args">Positional parameters for the filter string</param>
            <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Count(NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Returns the number of records of the specified 
            type in the database
            </summary>
            <param name="detachedCriteria">The criteria expression</param>
            <returns>The count result</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Exists">
            <summary>
            Check if there is any records in the db for the target type
            </summary>
            <returns><c>true</c> if there's at least one row</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Exists(System.String,System.Object[])">
            <summary>
            Check if there is any records in the db for the target type
            </summary>
            <param name="filter">A sql where string i.e. Person=? and DOB &gt; ?</param>
            <param name="args">Positional parameters for the filter string</param>
            <returns><c>true</c> if there's at least one row</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Exists(System.Object)">
            <summary>
            Check if the <paramref name="id"/> exists in the database.
            </summary>
            <param name="id">The id to check on</param>
            <returns><c>true</c> if the ID exists; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Exists(NHibernate.Criterion.ICriterion[])">
            <summary>
            Check if any instance matches the criteria.
            </summary>
            <returns><c>true</c> if an instance is found; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordMediator`1.Exists(NHibernate.Criterion.DetachedCriteria)">
            <summary>
            Check if any instance matching the criteria exists in the database.
            </summary>
            <param name="detachedCriteria">The criteria expression</param>		
            <returns><c>true</c> if an instance is found; otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Castle.ActiveRecord.SessionFactoryHolderDelegate">
            <summary>
            Delegate for use in <see cref="E:Castle.ActiveRecord.ActiveRecordStarter.ModelsCreated"/> and <see cref="E:Castle.ActiveRecord.ActiveRecordStarter.ModelsValidated"/>
            </summary>
            <param name="holder"></param>
        </member>
        <member name="T:Castle.ActiveRecord.ModelsDelegate">
            <summary>
            Delegate for use in <see cref="E:Castle.ActiveRecord.ActiveRecordStarter.ModelsCreated"/> and <see cref="E:Castle.ActiveRecord.ActiveRecordStarter.ModelsValidated"/>
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ModelDelegate">
            <summary>
            Delegate for use in <see cref="E:Castle.ActiveRecord.ActiveRecordStarter.ModelCreated"/>
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.EventListenerRegistrationDelegate">
            <summary>
            Delegate for AR Facility registration hooks.
            </summary>
            <param name="contributor"></param>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordStarter">
            <summary>
            Performs the framework initialization.
            </summary>
            <remarks>
            This class is not thread safe.
            </remarks>
        </member>
        <member name="F:Castle.ActiveRecord.ActiveRecordStarter.configSource">
            <summary>
            This is saved so one can invoke <c>RegisterTypes</c> later
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.ActiveRecordStarter.schemaDelimiter">
            <summary>
            The schema delimiter that is used by the hbm2ddl tool.
            Change the delimiter by calling <see cref="M:Castle.ActiveRecord.ActiveRecordStarter.SetSchemaDelimiter(System.String)"/>.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.ActiveRecordStarter.defaultSchemaDelimiter">
            <summary>
            The default schema delimiter. The delimiter of the schema is only set if 
            <see cref="F:Castle.ActiveRecord.ActiveRecordStarter.schemaDelimiter"/> is different from this default value.
            The default should be the same as the default delimiter of the hbm2ddl tool.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.Initialize(Castle.ActiveRecord.Framework.IConfigurationSource,System.Type[])">
            <summary>
            Initialize the mappings using the configuration and 
            the list of types
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.Initialize(System.Reflection.Assembly,Castle.ActiveRecord.Framework.IConfigurationSource)">
            <summary>
            Initialize the mappings using the configuration and 
            checking all the types on the specified <c>Assembly</c>
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.Initialize(System.Reflection.Assembly[],Castle.ActiveRecord.Framework.IConfigurationSource,System.Type[])">
            <summary>
            Initialize the mappings using the configuration and 
            checking all the types on the specified Assemblies
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.Initialize">
            <summary>
            Initializes the framework reading the configuration from
            the <c>AppDomain</c> and checking all the types on the executing <c>Assembly</c>
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.RegisterAssemblies(System.Reflection.Assembly[])">
            <summary>
            Registers new assemblies in ActiveRecord
            Usefull for dynamic assembly-adding after initialization
            </summary>
            <param name="assemblies"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.RegisterTypes(System.Type[])">
            <summary>
            Registers new types in ActiveRecord
            Usefull for dynamic type-adding after initialization
            </summary>
            <param name="types"></param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.CreateSchema">
            <summary>
            Generates and executes the creation scripts for the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.CreateSchema(System.Type)">
            <summary>
            Generates and executes the creation scripts for the database using 
            the specified baseClass to know which database it should create the schema for.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.CreateSchemaFromFile(System.String)">
            <summary>
            Executes the specified script to create/drop/change the database schema
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.CreateSchemaFromFile(System.String,System.Data.IDbConnection)">
            <summary>
            Executes the specified script to create/drop/change the database schema
            against the specified database connection
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.DropSchema">
            <summary>
            Generates and executes the Drop scripts for the database.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.DropSchema(System.Type)">
            <summary>
            Generates and executes the Drop scripts for the database using 
            the specified baseClass to know which database it should create the scripts for.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.UpdateSchema">
            <summary>
            Generates and executes the creation scripts for the database.
            </summary>
            <returns>List of exceptions that occurred during the update process</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.UpdateSchema(System.Type)">
            <summary>
            Generates and executes the creation scripts for the database using 
            the specified baseClass to know which database it should create the schema for.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.GenerateDropScripts(System.String)">
            <summary>
            Generates the drop scripts for the database saving them to the supplied file name. 
            </summary>
            <remarks>
            If ActiveRecord was configured to access more than one database, a file is going
            to be generate for each, based on the path and the <c>fileName</c> specified.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.GenerateDropScripts(System.Type,System.String)">
            <summary>
            Generates the drop scripts for the database saving them to the supplied file name. 
            The baseType is used to identify which database should we act upon.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.GenerateCreationScripts(System.String)">
            <summary>
            Generates the creation scripts for the database
            </summary>
            <remarks>
            If ActiveRecord was configured to access more than one database, a file is going
            to be generate for each, based on the path and the <c>fileName</c> specified.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.GenerateCreationScripts(System.Type,System.String)">
            <summary>
            Generates the creation scripts for the database
            The baseType is used to identify which database should we act upon.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.ResetInitializationFlag">
            <summary>
            Intended to be used only by test cases
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.SetSchemaDelimiter(System.String)">
            <summary>
            Sets the schema delimiter that is used for the creation of schema scripts.
            For example, <see cref="M:Castle.ActiveRecord.ActiveRecordStarter.CreateSchema"/>, <see cref="M:Castle.ActiveRecord.ActiveRecordStarter.DropSchema"/>, 
            <see cref="M:Castle.ActiveRecord.ActiveRecordStarter.GenerateCreationScripts(System.String)"/> and <see cref="M:Castle.ActiveRecord.ActiveRecordStarter.GenerateDropScripts(System.String)"/> 
            use the delimiter in the schema they create.
            </summary>
            <param name="newDelimiter">The new schema delimiter.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.GetRegisteredTypes">
            <summary>
            Retrieves a copy of the types registered within ActiveRecord
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.RegisterExtension(Castle.ActiveRecord.Framework.Internal.IModelBuilderExtension)">
            <summary>
            Registers a builder extension.
            </summary>
            <param name="extension">The extension.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.IsActiveRecordType(System.Reflection.ICustomAttributeProvider)">
            <summary>
            Return true if the type has a [ActiveRecord] attribute
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.CollectValidActiveRecordTypesFromAssembly(System.Reflection.Assembly,System.Collections.Generic.ICollection{System.Type},Castle.ActiveRecord.Framework.IConfigurationSource)">
            <summary>
            Retrieve all classes decorated with ActiveRecordAttribute or that have been configured
            as a AR base class.
            </summary>
            <param name="assembly">Assembly to retrieve types from</param>
            <param name="list">Array to store retrieved types in</param>
            <param name="source">IConfigurationSource to inspect AR base declarations from</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.CreateAnotherFile(System.String,System.Int32)">
            <summary>
            Generate a file name based on the original file name specified, using the 
            count to give it some order.
            </summary>
            <param name="originalFileName"></param>
            <param name="fileCount"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.AddContributor(Castle.ActiveRecord.Framework.INHContributor)">
            <summary>
            Adds a contributor instance that will be called when a configuration is
            prepared for creating a session factory 
            </summary>
            <param name="contributor">The contributor to add.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordStarter.ClearContributors">
            <summary>
            Clears the contributor registry. Mainly used for tests.
            </summary>
        </member>
        <member name="E:Castle.ActiveRecord.ActiveRecordStarter.SessionFactoryHolderCreated">
            <summary>
            So others frameworks can intercept the 
            creation and act on the holder instance
            </summary>
        </member>
        <member name="E:Castle.ActiveRecord.ActiveRecordStarter.MappingRegisteredInConfiguration">
            <summary>
            So others frameworks can intercept the 
            creation and act on the holder instance after
            the mapping was already loaded into the NHibernate 
            </summary>
        </member>
        <member name="E:Castle.ActiveRecord.ActiveRecordStarter.ModelsCreated">
            <summary>
            Allows other frameworks to modify the ActiveRecordModel
            before the generation of the NHibernate XML configuration.
            As an example, this may be used to rewrite table names to
            conform to an application-specific standard.  Since the
            configuration source is passed in, it is possible to
            determine the underlying database type and make changes
            if necessary.
            </summary>
        </member>
        <member name="E:Castle.ActiveRecord.ActiveRecordStarter.ModelsValidated">
            <summary>
            Allows other frameworks to modify the ActiveRecordModel
            before the generation of the NHibernate XML configuration.
            As an example, this may be used to rewrite table names to
            conform to an application-specific standard.  Since the
            configuration source is passed in, it is possible to
            determine the underlying database type and make changes
            if necessary.
            </summary>
        </member>
        <member name="E:Castle.ActiveRecord.ActiveRecordStarter.ModelCreated">
            <summary>
            Allows other frameworks to modify the ActiveRecordModel
            before the generation of the NHibernate XML configuration.
            </summary>
        </member>
        <member name="E:Castle.ActiveRecord.ActiveRecordStarter.EventListenerComponentRegistrationHook">
            <summary>
            Allows the ActiveRecordFacility to register components as event listeners;
            </summary>
        </member>
        <member name="E:Castle.ActiveRecord.ActiveRecordStarter.EventListenerFacilityConfigurationHook">
            <summary>
            Allows the ActiveRecordFacility to reconfigure registered listeners.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordStarter.IsInitialized">
            <summary>
            Gets a value indicating whether ActiveRecord was initialized properly (see the Initialize method).
            </summary>
            <value>
            	<c>true</c> if it is initialized; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordStarter.ConfigurationSource">
            <summary>
            The current <see cref="T:Castle.ActiveRecord.Framework.IConfigurationSource"/>.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordValidationBase">
            <summary>
            Extends <see cref="T:Castle.ActiveRecord.ActiveRecordBase"/> adding automatic validation support.
            </summary>
            <example>
            <code>
            using Castle.Components.Validator;
            
            public class Customer : ActiveRecordBase
            {
            	...
            	
            	[Property, ValidateNonEmpty]
            	public int Name
            	{
            		get { return _name; }
            		set { _name = value; }
            	}
            	
            	[Property, ValidateNonEmpty, ValidateEmail]
            	public int Email
            	{
            		get { return _email; }
            		set { _email = value; }
            	}
            </code>
            </example>
        </member>
        <member name="F:Castle.ActiveRecord.ActiveRecordValidationBase._actualValidator">
            <summary>
            Field for <see cref="P:Castle.ActiveRecord.ActiveRecordValidationBase.ActualValidator"/>.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.#ctor">
            <summary>
            Constructs an ActiveRecordValidationBase
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.IsValid">
            <summary>
            Performs the fields validation. Returns true if no 
            validation error was found.
            </summary>
            <returns></returns>
            <remarks>Forwards the call to <see cref="P:Castle.ActiveRecord.ActiveRecordValidationBase.ActualValidator"/>.</remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.IsValid(Castle.Components.Validator.RunWhen)">
            <summary>
            Performs the fields validation for the specified action.
            </summary>
            <param name="runWhen">Use validators appropriate to the action being performed.</param>
            <returns>True if no validation error was found</returns>
            <remarks>Forwards the call to <see cref="P:Castle.ActiveRecord.ActiveRecordValidationBase.ActualValidator"/>.</remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.BeforeSave(System.Collections.IDictionary)">
            <summary>
            Override the base hook to call validators required for create.
            </summary>
            <param name="state">The current state of the object</param>
            <returns>Returns true if the state has changed otherwise false</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.OnFlushDirty(System.Object,System.Collections.IDictionary,System.Collections.IDictionary,NHibernate.Type.IType[])">
            <summary>
            Override the base hook to call validators required for update.
            </summary>
            <param name="id">object id</param>
            <param name="previousState">The previous state of the object</param>
            <param name="currentState">The current state of the object</param>
            <param name="types">Property types</param>
            <returns>Returns true if the state has changed otherwise false</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase.OnNotValid">
            <summary>
            Throws an exception explaining why the save or update
            cannot be executed when fields are not ok to pass.
            </summary>
            <remarks>
            You can override this method to declare a better behavior.
            </remarks>
            <remarks>Forwards the call to <see cref="P:Castle.ActiveRecord.ActiveRecordValidationBase.ActualValidator"/>.</remarks>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidationBase.ActualValidator">
            <summary>
            Gets the <see cref="T:Castle.ActiveRecord.Framework.IValidationProvider"/> that actually validates this AR object.
            Normally returns a <see cref="T:Castle.ActiveRecord.ActiveRecordValidator"/>, but you can override this
            to return a custom validator.
            </summary>
            <value>The validator.</value>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidationBase.ValidationErrorMessages">
            <summary>
            Returns a list of current validation errors messages.
            </summary>
            <remarks>Forwards the call to <see cref="P:Castle.ActiveRecord.ActiveRecordValidationBase.ActualValidator"/>.</remarks>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidationBase.PropertiesValidationErrorMessages">
            <summary>
            Maps a specific PropertyInfo to a list of
            error messages. Useful for frameworks.
            </summary>
            <remarks>Forwards the call to <see cref="P:Castle.ActiveRecord.ActiveRecordValidationBase.ActualValidator"/>.</remarks>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordValidationBase`1">
             <summary>
             Extends <see cref="T:Castle.ActiveRecord.ActiveRecordBase"/> adding automatic validation support.
             <seealso cref="M:Castle.ActiveRecord.ActiveRecordValidationBase.IsValid"/>
             </summary>
             <example>
             <code>
             using Castle.Components.Validator;
            
             public class Customer : ActiveRecordBase
             {
            		...
            		
            		[Property, ValidateNonEmpty]
            		public int Name
            		{
            			get { return _name; }
            			set { _name = value; }
            		}
            		
            		[Property, ValidateNonEmpty, ValidateEmail]
            		public int Email
            		{
            			get { return _email; }
            			set { _email = value; }
            		}
            	</code>
             </example>
        </member>
        <member name="F:Castle.ActiveRecord.ActiveRecordValidationBase`1._actualValidator">
            <summary>
            Field for <see cref="P:Castle.ActiveRecord.ActiveRecordValidationBase`1.ActualValidator"/>.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase`1.#ctor">
            <summary>
            Constructs an ActiveRecordValidationBase
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase`1.IsValid">
            <summary>
            Performs the fields validation. Returns true if no 
            validation error was found.
            </summary>
            <returns></returns>
            <remarks>Forwards the call to <see cref="P:Castle.ActiveRecord.ActiveRecordValidationBase`1.ActualValidator"/>.</remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase`1.IsValid(Castle.Components.Validator.RunWhen)">
            <summary>
            Performs the fields validation for the specified action.
            </summary>
            <param name="runWhen">Use validators appropriate to the action being performed.</param>
            <returns>True if no validation error was found</returns>
            <remarks>Forwards the call to <see cref="P:Castle.ActiveRecord.ActiveRecordValidationBase`1.ActualValidator"/>.</remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase`1.BeforeSave(System.Collections.IDictionary)">
            <summary>
            Override the base hook to call validators required for create.
            </summary>
            <param name="state">The current state of the object</param>
            <returns>Returns true if the state has changed otherwise false</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase`1.OnFlushDirty(System.Object,System.Collections.IDictionary,System.Collections.IDictionary,NHibernate.Type.IType[])">
            <summary>
            Override the base hook to call validators required for update.
            </summary>
            <param name="id">object id</param>
            <param name="previousState">The previous state of the object</param>
            <param name="currentState">The current state of the object</param>
            <param name="types">Property types</param>
            <returns>Returns true if the state has changed otherwise false</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationBase`1.OnNotValid">
            <summary>
            Throws an exception explaining why the save or update
            cannot be executed when fields are not ok to pass.
            </summary>
            <remarks>
            You can override this method to declare a better behavior.
            </remarks>
            <remarks>Forwards the call to <see cref="P:Castle.ActiveRecord.ActiveRecordValidationBase`1.ActualValidator"/>.</remarks>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidationBase`1.ActualValidator">
            <summary>
            Gets the <see cref="T:Castle.ActiveRecord.Framework.IValidationProvider"/> that actually validates this AR object.
            Normally returns a <see cref="T:Castle.ActiveRecord.ActiveRecordValidator"/>, but you can override this
            to return a custom validator.
            </summary>
            <value>The validator.</value>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidationBase`1.ValidationErrorMessages">
            <summary>
            Returns a list of current validation errors messages.
            </summary>
            <remarks>Forwards the call to <see cref="P:Castle.ActiveRecord.ActiveRecordValidationBase`1.ActualValidator"/>.</remarks>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidationBase`1.PropertiesValidationErrorMessages">
            <summary>
            Maps a specific PropertyInfo to a list of
            error messages. Useful for frameworks.
            </summary>
            <remarks>Forwards the call to <see cref="P:Castle.ActiveRecord.ActiveRecordValidationBase`1.ActualValidator"/>.</remarks>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordValidationException">
            <summary>
            Thrown when a AR object does not pass the validation when it is saved or updated.
            The <see cref="P:Castle.ActiveRecord.ActiveRecordValidationException.PropertiesValidationErrorMessages"/> is a map 
            of failed properties and their validation errors. 
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ActiveRecordValidationException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ActiveRecordValidationException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationException.#ctor(System.String,System.String[],System.Collections.IDictionary)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ActiveRecordValidationException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="validationErrorMessages">The error messages.</param>
            <param name="propertiesValidationErrorMessages">An optional map of failed properties and their validation errors.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationException.#ctor(System.String,System.Exception,System.String[],System.Collections.IDictionary)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ActiveRecordValidationException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
            <param name="validationErrorMessages">The error messages.</param>
            <param name="propertiesValidationErrorMessages">An optional map of failed properties and their validation errors.</param>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.ActiveRecordValidationException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"></see> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"></see> is zero (0). </exception>
            <exception cref="T:System.ArgumentNullException">The info parameter is null. </exception>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidationException.PropertiesValidationErrorMessages">
            <summary>
            Maps a specific PropertyInfo to a list of error messages. 
            Useful to see which property failed the validation when the object tried to be persisted.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidationException.FailedProperties">
            <summary>
            Gets the failed properties as an array of PropertyInfos.
            </summary>
            <value>The failed properties.</value>
        </member>
        <member name="T:Castle.ActiveRecord.ActiveRecordValidator">
            <summary>
            Provides the implementation of <see cref="T:Castle.ActiveRecord.Framework.IValidationProvider"/>. 
            An AR clas that wants to implement <see cref="T:Castle.ActiveRecord.Framework.IValidationProvider"/> 
            can use an instance of this class to delegate the validation methods and properties
            </summary>
            <remarks>
            This class contains the validation logic that was previously duplicated in 
            ActiveRecordValidationBase and ActiveRecordValidationBase&lt;T&gt;
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidator.#ctor(System.Object)">
            <summary>
            Constructs an ActiveRecordValidator
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidator.IsValid">
            <summary>
            Performs the fields validation. Returns true if no 
            validation error was found.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidator.IsValid(Castle.Components.Validator.RunWhen)">
            <summary>
            Performs the fields validation for the specified action.
            </summary>
            <param name="runWhen">Use validators appropriate to the action being performed.</param>
            <returns>True if no validation error was found</returns>
        </member>
        <member name="M:Castle.ActiveRecord.ActiveRecordValidator.ThrowNotValidException(System.String[],System.Collections.IDictionary)">
            <summary>
            Throws an exception explaining why the save or update
            cannot be executed when fields are not ok to pass.
            </summary>
            <remarks>
            You can override this method to declare a better behavior.
            </remarks>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidator.ValidationErrorMessages">
            <summary>
            Returns a list of current validation errors messages.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidator.PropertiesValidationErrorMessages">
            <summary>
            Maps a specific PropertyInfo to a list of
            error messages. Useful for frameworks.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidator.Runner">
            <summary>
            Gets the <see cref="T:Castle.Components.Validator.ValidatorRunner"/> to actually perform the validation.
            </summary>
            <value>The runner.</value>
        </member>
        <member name="P:Castle.ActiveRecord.ActiveRecordValidator.ARObjectInstance">
            <summary>
            Gets the AR object instance that 
            uses this <see cref="T:Castle.ActiveRecord.ActiveRecordValidator"/> to do the validation.
            </summary>
            <value>The AR object instance.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.Internal.ARSchemaCreator">
            <summary>
            Used to execute a script file to create/update/drop 
            a database schema. Inspired on NHibernate SchemaExport class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ARSchemaCreator.#ctor(NHibernate.Cfg.Configuration)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.Internal.ARSchemaCreator"/> class.
            </summary>
            <param name="config">The config.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ARSchemaCreator.Execute(System.String)">
            <summary>
            Executes the specified script file.
            </summary>
            <param name="scriptFileName">Name of the script file.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ARSchemaCreator.ExecuteScriptParts(System.Data.IDbConnection,System.String[])">
            <summary>
            Executes the script parts.
            </summary>
            <param name="connection">The connection.</param>
            <param name="parts">The parts.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.Internal.ARSchemaCreator.OpenFileAndStripContents(System.String)">
            <summary>
            Opens the file and return an array of seperate commands that it contains
            </summary>
            <param name="scriptFileName">Name of the script file.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.CriteriaHelper.AddCriterionToCriteria(NHibernate.ICriteria,NHibernate.Criterion.ICriterion[])">
            <summary>
            Adds a collection of ICriterion to an ICriteria.
            </summary>
            <param name="criteria">The ICriteria that will be modified.</param>
            <param name="criterions">The collection of Criterion.</param>
        </member>
        <member name="M:Castle.ActiveRecord.CriteriaHelper.AddOrdersToCriteria(NHibernate.ICriteria,NHibernate.Criterion.Order[])">
            <summary>
            Adds a collection of Order (sort by) specifiers to an ICriteria.
            </summary>
            <param name="criteria">The ICriteria that will be modified.</param>
            <param name="orders">The collection of Order specifiers.</param>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.DictionaryAdapter">
            <summary>
            Maps keys to position in the values array. 
            Basically key -> index
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.#ctor(System.String[],System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.DictionaryAdapter"/> class.
            </summary>
            <param name="names">The names.</param>
            <param name="values">The values.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.Contains(System.Object)">
            <summary>
            Determines whether the <see cref="T:System.Collections.IDictionary"></see> object contains an element with the specified key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:System.Collections.IDictionary"></see> object.</param>
            <returns>
            true if the <see cref="T:System.Collections.IDictionary"></see> contains an element with the key; otherwise, false.
            </returns>
            <exception cref="T:System.ArgumentNullException">key is null. </exception>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.Add(System.Object,System.Object)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
            <param name="key">The <see cref="T:System.Object"></see> to use as the key of the element to add.</param>
            <param name="value">The <see cref="T:System.Object"></see> to use as the value of the element to add.</param>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.IDictionary"></see> object. </exception>
            <exception cref="T:System.ArgumentNullException">key is null. </exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> is read-only.-or- The <see cref="T:System.Collections.IDictionary"></see> has a fixed size. </exception>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.Clear">
            <summary>
            Removes all elements from the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> object is read-only. </exception>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.System#Collections#IDictionary#GetEnumerator">
            <summary>
            Returns an <see cref="T:System.Collections.IDictionaryEnumerator"></see> object for the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IDictionaryEnumerator"></see> object for the <see cref="T:System.Collections.IDictionary"></see> object.
            </returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.Remove(System.Object)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.IDictionary"></see> object is read-only.-or- The <see cref="T:System.Collections.IDictionary"></see> has a fixed size. </exception>
            <exception cref="T:System.ArgumentNullException">key is null. </exception>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"></see> to an <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"></see>. The <see cref="T:System.Array"></see> must have zero-based indexing.</param>
            <param name="index">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">array is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">index is less than zero. </exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or- index is equal to or greater than the length of array.-or- The number of elements in the source <see cref="T:System.Collections.ICollection"></see> is greater than the available space from index to the end of the destination array. </exception>
            <exception cref="T:System.InvalidCastException">The type of the source <see cref="T:System.Collections.ICollection"></see> cannot be cast automatically to the type of the destination array. </exception>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.DictionaryAdapter.Keys">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"></see> object containing the keys of the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
            <value></value>
            <returns>An <see cref="T:System.Collections.ICollection"></see> object containing the keys of the <see cref="T:System.Collections.IDictionary"></see> object.</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.DictionaryAdapter.Values">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"></see> object containing the values in the <see cref="T:System.Collections.IDictionary"></see> object.
            </summary>
            <value></value>
            <returns>An <see cref="T:System.Collections.ICollection"></see> object containing the values in the <see cref="T:System.Collections.IDictionary"></see> object.</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.DictionaryAdapter.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"></see> object is read-only.
            </summary>
            <value></value>
            <returns>true if the <see cref="T:System.Collections.IDictionary"></see> object is read-only; otherwise, false.</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.DictionaryAdapter.IsFixedSize">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.IDictionary"></see> object has a fixed size.
            </summary>
            <value></value>
            <returns>true if the <see cref="T:System.Collections.IDictionary"></see> object has a fixed size; otherwise, false.</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.DictionaryAdapter.Item(System.Object)">
            <summary>
            Gets or sets the <see cref="T:System.Object"/> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.DictionaryAdapter.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
            <value></value>
            <returns>The number of elements contained in the <see cref="T:System.Collections.ICollection"></see>.</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.DictionaryAdapter.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
            <value></value>
            <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.DictionaryAdapter.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe).
            </summary>
            <value></value>
            <returns>true if access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe); otherwise, false.</returns>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.DictionaryAdapter.Entry">
            <summary>
            Simple link list entry
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.Entry.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.DictionaryAdapter.Entry"/> class.
            </summary>
            <param name="key">The key.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.DictionaryAdapter.Entry.Find(System.String)">
            <summary>
            Finds the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.HookDispatcher">
            <summary>
            Translates the <c>IInterceptor</c>
            messages to instance possible hooks
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.HookDispatcher"/> class.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.OnLoad(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called just before an object is initialized
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may change the <c>state</c>, which will be propagated to the persistent
            object. Note that when this method is called, <c>entity</c> will be an empty
            uninitialized instance of the class.</remarks>
            <returns><c>true</c> if the user modified the <c>state</c> in any way</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.OnFlushDirty(System.Object,System.Object,System.Object[],System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called when an object is detected to be dirty, during a flush.
            </summary>
            <param name="currentState"></param>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="previousState"></param>
            <param name="propertyNames"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may modify the detected <c>currentState</c>, which will be propagated to
            both the database and the persistent object. Note that all flushes end in an actual
            synchronization with the database, in which as the new <c>currentState</c> will be propagated
            to the object, but not necessarily (immediately) to the database. It is strongly recommended
            that the interceptor <b>not</b> modify the <c>previousState</c>.
            </remarks>
            <returns><c>true</c> if the user modified the <c>currentState</c> in any way</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.OnSave(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called before an object is saved
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may modify the <c>state</c>, which will be used for the SQL <c>INSERT</c>
            and propagated to the persistent object
            </remarks>
            <returns><c>true</c> if the user modified the <c>state</c> in any way</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.OnDelete(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called before an object is deleted
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            It is not recommended that the interceptor modify the <c>state</c>.
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.PreFlush(System.Collections.ICollection)">
            <summary>
            Called before a flush
            </summary>
            <param name="entities">The entities</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.IsTransient(System.Object)">
            <summary>
            Called when a transient entity is passed to <c>SaveOrUpdate</c>.
            </summary>
            <remarks>
            The return value determines if the object is saved
            <list>
            	<item><see langword="true" /> - the entity is passed to <c>Save()</c>, resulting in an <c>INSERT</c></item>
            	<item><see langword="false" /> - the entity is passed to <c>Update()</c>, resulting in an <c>UPDATE</c></item>
            	<item><see langword="null" /> - Hibernate uses the <c>unsaved-value</c> mapping to determine if the object is unsaved</item>
            </list>
            </remarks>
            <param name="entity">A transient entity</param>
            <returns>Boolean or <see langword="null" /> to choose default behaviour</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.PostFlush(System.Collections.ICollection)">
            <summary>
            Called after a flush that actually ends in execution of the SQL statements required to
            synchronize in-memory state with the database.
            </summary>
            <param name="entities">The entitites</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.FindDirty(System.Object,System.Object,System.Object[],System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called from <c>Flush()</c>. The return value determines whether the entity is updated
            </summary>
            <remarks>
            	<list>
            		<item>an array of property indicies - the entity is dirty</item>
            		<item>an empty array - the entity is not dirty</item>
            		<item><c>null</c> - use Hibernate's default dirty-checking algorithm</item>
            	</list>
            </remarks>
            <param name="entity">A persistent entity</param>
            <param name="currentState"></param>
            <param name="id"></param>
            <param name="previousState"></param>
            <param name="propertyNames"></param>
            <param name="types"></param>
            <returns>An array of dirty property indicies or <c>null</c> to choose default behavior</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.HookDispatcher.Instantiate(System.String,NHibernate.EntityMode,System.Object)">
            <summary>
            Instantiate the entity class. Return <see langword="null" /> to indicate that Hibernate should use the default
            constructor of the class
            </summary>
            <param name="entityName">the name of the entity </param>
            <param name="entityMode">The type of entity instance to be returned. </param>
            <param name="id">the identifier of the new instance </param>
            <returns>An instance of the class, or <see langword="null" /> to choose default behaviour</returns>
            <remarks>
            The identifier property of the returned instance
            should be initialized with the given identifier.
            </remarks>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.HookDispatcher.Instance">
            <summary>
            Gets the sole instance.
            </summary>
            <value>The instance.</value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.InterceptorFactory">
            <summary>
            Create an interceptor for the session.
            Allow to override the default for creating the intercetor
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.InterceptorFactory.Create">
            <summary>
            Create the 
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.InterceptorFactory.CreateInterceptor">
            <summary>
            Creates an instance of the interceptor
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.RootTypeHandler">
            <summary>
            Type of delegate that is called when a root type is registered.
            </summary>
            <param name="sender"></param>
            <param name="rootType"></param>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder">
            <summary>
            Keeps an association of SessionFactories to a object model 
            tree;
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.Register(System.Type,NHibernate.Cfg.Configuration)">
            <summary>
            Associates a Configuration object to a root type
            </summary>
            <param name="rootType"></param>
            <param name="cfg"></param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.GetAllConfigurations">
            <summary>
            Pendent
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.GetConfiguration(System.Type)">
            <summary>
            Requests the Configuration associated to the type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.GetSessionFactory(System.Type)">
            <summary>
            Obtains the SessionFactory associated to the type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.GetSessionFactories">
            <summary>
            Gets the all the session factories.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.CreateSession(System.Type)">
            <summary>
            Creates a session for the associated type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.ReleaseSession(NHibernate.ISession)">
            <summary>
            Releases the specified session
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.FailSession(NHibernate.ISession)">
            <summary>
            Called if an action on the session fails
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.GetRootType(System.Type)">
            <summary>
            Gets the type of the root.
            </summary>
            <param name="type">The type.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.ISessionFactoryHolder.RegisterSessionFactory(NHibernate.ISessionFactory,System.Type)">
            <summary>
             This method allows direct registration
             of a session factory to a type, bypassing the normal preperation that AR
             usually does. 
             The main usage is in testing, so you would be able to switch the session factory
             for each test.
             Note that this will override the current session factory for the baseType.
            </summary>
        </member>
        <member name="E:Castle.ActiveRecord.Framework.ISessionFactoryHolder.OnRootTypeRegistered">
            <summary>
            Raised when a new root type is registered. 
            A new root type creates a new <c>ISessionFactory</c>
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.ISessionFactoryHolder.ThreadScopeInfo">
            <summary>
            Gets or sets the implementation of <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/>
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.NHEventListeners">
            <summary>
            This contributor allows easy adding of NHibernate event listeners to
            configurations. It implements a kind of multiple-strongly-typed collection
            for all event listener types. Those types will be added to all
            <see cref="T:NHibernate.Cfg.Configuration"/>-objects that are not filtered
            by the <see cref="P:Castle.ActiveRecord.Framework.INHContributor.AppliesToRootType"/> double dispatch filter.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.NHEventListeners.Add``1(``0)">
            <summary>
            Adds an event listener that will be added to all configurations served.
            </summary>
            <typeparam name="TListener">the event listener type to add</typeparam>
            <param name="listenerInstance">the listener instance to add</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.NHEventListeners.Remove``1(``0)">
            <summary>
            Removes a previously added listener instance
            </summary>
            <typeparam name="TListener">the type of the instance</typeparam>
            <param name="listenerInstance">the instance to remove</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.NHEventListeners.Contains``1(``0)">
            <summary>
            Tests if a listener instance has been added
            </summary>
            <typeparam name="TListener">the instance's type</typeparam>
            <param name="listenerInstance">the instance to test for</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.NHEventListeners.Enumerate``1">
            <summary>
            Enumerates all listener instances of the given type
            </summary>
            <typeparam name="TEventType">the requested event type</typeparam>
            <returns>all listeners of the requested type</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.NHEventListeners.Contribute(NHibernate.Cfg.Configuration)">
            <summary>
            Configures the configuration with all registered listeners
            </summary>
            <param name="configuration">the configuration object to add the listeners to</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.NHEventListeners.ConfigureListenerType(NHibernate.Cfg.Configuration,System.Type)">
            <summary>
            Configures the configures with the registered listeners of the given type
            </summary>
            <param name="configuration">the configuration object to add the listeners to</param>
            <param name="listenerType">the listener type to use</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.NHEventListeners.GetEventListenerTypes">
            <summary>
            Returns all event listener interfaces defined by NHibernate
            </summary>
            <returns>event listener interface types</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.NHEventListeners.GetProperty(System.Type)">
            <summary>
            Returns the PropertyInfo of the <see cref="T:NHibernate.Event.EventListeners"/>-class for
            a given EventListener-interface.
            </summary>
            <param name="listenerType">The listener interface</param>
            <returns>the property info object</returns>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.NHEventListeners.ReplaceExistingListeners">
            <summary>
            Replaces existing listeners instead of adding them if set to <code>true</code>.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.NHSearchContributor">
            <summary>
            Contributor to add the NHSearch event listeners
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.NHSearchContributor.Contribute(NHibernate.Cfg.Configuration)">
            <summary>
            The actual contribution method.
            </summary>
            <param name="configuration">The configuration to be modified.</param>
        </member>
        <member name="T:Castle.ActiveRecord.NotFoundException">
            <summary>
            This exception is thrown when loading an entity by its PK failed because the entity did not exist.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.NotFoundException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.NotFoundException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.ActiveRecord.NotFoundException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.NotFoundException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.ActiveRecord.NotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.NotFoundException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"></see> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"></see> is zero (0). </exception>
            <exception cref="T:System.ArgumentNullException">The info parameter is null. </exception>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.SessionFactoryHolder">
            <summary>
            Default implementation of <seealso cref="T:Castle.ActiveRecord.Framework.ISessionFactoryHolder"/>
            </summary>
            <remarks>
            This class is thread safe
            </remarks>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.Register(System.Type,NHibernate.Cfg.Configuration)">
            <summary>
            Associates a Configuration object to a root type
            </summary>
            <param name="rootType"></param>
            <param name="cfg"></param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.GetConfiguration(System.Type)">
            <summary>
            Requests the Configuration associated to the type.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.GetAllConfigurations">
            <summary>
            Pendent
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.GetSessionFactories">
            <summary>
            Gets the all the session factories.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.GetSessionFactory(System.Type)">
            <summary>
            Optimized with reader/writer lock.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.RegisterSessionFactory(NHibernate.ISessionFactory,System.Type)">
            <summary>
             This method allows direct registration
             of a session factory to a type, bypassing the normal preperation that AR
             usually does. 
             The main usage is in testing, so you would be able to switch the session factory
             for each test.
             Note that this will override the current session factory for the baseType.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.CreateSession(System.Type)">
            <summary>
            Creates a session for the associated type
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.GetRootType(System.Type)">
            <summary>
            Gets the type of the root.
            </summary>
            <param name="type">The type.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.ReleaseSession(NHibernate.ISession)">
            <summary>
            Releases the specified session
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionFactoryHolder.FailSession(NHibernate.ISession)">
            <summary>
            Called if an action on the session fails
            </summary>
            <param name="session"></param>
        </member>
        <member name="E:Castle.ActiveRecord.Framework.SessionFactoryHolder.OnRootTypeRegistered">
            <summary>
            Raised when a root type is registered.
            </summary>
        </member>
        <member name="P:Castle.ActiveRecord.Framework.SessionFactoryHolder.ThreadScopeInfo">
            <summary>
            Gets or sets the implementation of <see cref="T:Castle.ActiveRecord.Framework.IThreadScopeInfo"/>
            </summary>
            <value></value>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.SessionScopeWebModule">
            <summary>
            HttpModule to set up a session for the request lifetime.
            <seealso cref="T:Castle.ActiveRecord.SessionScope"/>
            </summary>
            <remarks>
            To install the module, you must:
            <para>
               <list type="number">
                 <item>
                   <description>
                   Add the module to the <c>httpModules</c> configuration section within <c>system.web</c>
                   </description>
                 </item>
               </list>
            </para>
            </remarks>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.SessionScopeWebModule.SessionKey">
            <summary>
            The key used to store the session in the context items
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.SessionScopeWebModule.isWebConfigured">
            <summary>
            Used to check whether the ThreadScopeInfo being used is suitable for a web environment
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionScopeWebModule.Init(System.Web.HttpApplication)">
            <summary>
            Initialize the module.
            </summary>
            <param name="app">The app.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionScopeWebModule.Dispose">
            <summary>
            Disposes of the resources (other than memory) used by the module that implements <see cref="T:System.Web.IHttpModule"></see>.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionScopeWebModule.OnBeginRequest(System.Object,System.EventArgs)">
            <summary>
            Called when request is started, create a session for the request
            </summary>
            <param name="sender">The sender.</param>
            <param name="e">The <see cref="T:System.EventArgs"/> instance containing the event data.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SessionScopeWebModule.OnEndRequest(System.Object,System.EventArgs)">
            <summary>
            Called when the request ends, dipose of the scope
            </summary>
            <param name="sender">The sender.</param>
            <param name="e">The <see cref="T:System.EventArgs"/> instance containing the event data.</param>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.StatelessSessionWrapper">
            <summary>
            Wraps a NHibernate.IStatelessSession and provides an interface of type
            <see cref="T:NHibernate.ISession"/> for it.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Framework.StatelessSessionWrapper.statelessSession">
            <summary>
            The stateless session to delegate to.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.StatelessSessionWrapper.#ctor(NHibernate.IStatelessSession)">
            <summary>
            Builds a StatelessSessionWrapper.
            </summary>
            <param name="statelessSession">The stateless session to delegate to.</param>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.NotWrappedException">
            <summary>
            Wraps a NotImplementedException with a preconfigured Catle-like
            excweption message.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.NotWrappedException.#ctor">
            <summary>
            Calls the base class' constructor with the preconfigured message.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.SupportingUtils">
            <summary>
            Contains utility methods for dealing with ActiveRecord objects
            and collections.
            Useful for external frameworks.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.FindAll(System.Type)">
            <summary>
            Obsolete method, use ActiveRecordMediator or ActiveRecordMediator{T} instead
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.FindByPK(System.Type,System.Object)">
            <summary>
            Obsolete method, use ActiveRecordMediator or ActiveRecordMediator{T} instead
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.FindByPK(System.Type,System.Object,System.Boolean)">
            <summary>
            Obsolete method, use ActiveRecordMediator or ActiveRecordMediator{T} instead
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildArray(System.Type,System.Collections.IList)">
            <summary>
            Create an array from an IList.
            </summary>
            <param name="targetType">Type of the item in the array.</param>
            <param name="list">The list.</param>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildArray(System.Type,System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Converts the results stored in an <see cref="T:System.Collections.IEnumerable"/> to an
            strongly-typed array.
            </summary>
            <param name="type">The type of the new array</param>
            <param name="list">The source list</param>
            <param name="distinct">If true, only distinct results will be inserted in the array</param>
            <returns>The strongly-typed array</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildArray(System.Type,System.Collections.IEnumerable,System.Int32,System.Boolean)">
            <summary>
            Converts the results stored in an <see cref="T:System.Collections.IEnumerable"/> to an
            strongly-typed array.
            </summary>
            <param name="type">The type of the new array</param>
            <param name="list">The source list</param>
            <param name="entityIndex">
            If the HQL clause selects more than one field, or a join is performed
            without using <c>fetch join</c>, the contents of the result list will
            be of type <c>object[]</c>. Specify which index in this array should be used to
            compose the new result array. Use <c>-1</c> to ignore this parameter.
            </param>
            <param name="distinct">If true, only distinct results will be inserted in the array</param>
            <returns>The strongly-typed array</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildObjectArray(System.Type,System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Converts the results stored in an <see cref="T:System.Collections.IEnumerable"/> to an
            strongly-typed array.
            </summary>
            <param name="type">
            The class of the object which will be created for each row contained in
            the supplied <paramref name="list"/>.
            </param>
            <param name="list">The source list</param>
            <param name="distinct">If true, only distinct results will be inserted in the array</param>
            <returns>The strongly-typed array</returns>
            <remarks>A good alternative is to use the new <see cref="T:Castle.ActiveRecord.ImportAttribute"/></remarks>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildObjectArray``1(System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Converts the results stored in an <see cref="T:System.Collections.IEnumerable"/> to an
            strongly-typed array.
            </summary>
            <typeparam name="T">The type of the new array</typeparam>
            <param name="list">The source list</param>
            <param name="distinct">If true, only distinct results will be inserted in the array</param>
            <returns>The strongly-typed array</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildArray``1(System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Converts the results stored in an <see cref="T:System.Collections.IEnumerable"/> to a
            strongly-typed array.
            </summary>
            <param name="list">The source list</param>
            <param name="distinct">If true, only distinct results will be inserted in the array</param>
            <returns>The strongly-typed array</returns>
            <typeparam name="T">
            The class of the object which will be created for each row contained in
            the supplied <paramref name="list"/>.
            </typeparam>
            <remarks>A good alternative is to use the new <see cref="T:Castle.ActiveRecord.ImportAttribute"/></remarks>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.SupportingUtils.BuildArray``1(System.Collections.IEnumerable,System.Nullable{System.Int32},System.Boolean)">
            <summary>
            Converts the results stored in an <see cref="T:System.Collections.IEnumerable"/> to an
            strongly-typed array.
            </summary>
            <typeparam name="T">The type of the new array</typeparam>
            <param name="list">The source list</param>
            <param name="entityIndex">
            If the HQL clause selects more than one field, or a join is performed
            without using <c>fetch join</c>, the contents of the result list will
            be of type <c>object[]</c>. Specify which index in this array should be used to
            compose the new result array. Use <c>-1</c> to ignore this parameter.
            </param>
            <param name="distinct">If true, only distinct results will be inserted in the array</param>
            <returns>The strongly-typed array</returns>
        </member>
        <member name="T:Castle.ActiveRecord.Framework.TransactionException">
            <summary>
            This exception is thrown by TransactionScope.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.TransactionException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.TransactionException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.TransactionException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.TransactionException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Framework.TransactionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Castle.ActiveRecord.Framework.TransactionException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"></see> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult"></see> is zero (0). </exception>
            <exception cref="T:System.ArgumentNullException">The info parameter is null. </exception>
        </member>
        <member name="T:Castle.ActiveRecord.Testing.InMemoryConnectionProvider">
            <summary>
            ConnectionProvider for Sqlite in memory tests, that suppresses closing
            the connection to keep the data until the test is finished.
            </summary>
        </member>
        <member name="F:Castle.ActiveRecord.Testing.InMemoryConnectionProvider.Connection">
            <summary>
            The connection to the database
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Testing.InMemoryConnectionProvider.GetConnection">
            <summary>
            Called by the framework.
            </summary>
            <returns>A connection to the database</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Testing.InMemoryConnectionProvider.CloseConnection(System.Data.IDbConnection)">
            <summary>
            No-Op.
            </summary>
            <param name="conn">The connection to close.</param>
        </member>
        <member name="M:Castle.ActiveRecord.Testing.InMemoryConnectionProvider.Restart">
            <summary>
            Closes the connection after the tests.
            </summary>
        </member>
        <member name="T:Castle.ActiveRecord.Testing.InMemoryTest">
            <summary>
            Base class for in memory unit tests. This class does not contain any
            attributes specific to a testing framework.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Testing.InMemoryTest.SetUp">
            <summary>
            The common test setup code. To activate it in a specific test framework,
            it must be called from a framework-specific setup-Method.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Testing.InMemoryTest.TearDown">
            <summary>
            The common test teardown code. To activate it in a specific test framework,
            it must be called from a framework-specific teardown-Method.
            </summary>
        </member>
        <member name="M:Castle.ActiveRecord.Testing.InMemoryTest.GetTypes">
            <summary>
            Method that must be overridden by the test fixtures to return the types
            that should be initialized. The stub returns an empty array.
            </summary>
            <returns>The types to initialize.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Testing.InMemoryTest.GetAssemblies">
            <summary>
            Method that must be overridden by the test fixtures to return the assemblies
            that should be initialized. The stub returns an empty array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Castle.ActiveRecord.Testing.InMemoryTest.GetAdditionalBaseClasses">
            <summary>
            Hook to allow the initialization of additional base classes. <see cref="T:Castle.ActiveRecord.ActiveRecordBase"/> is 
            added everytime and must not be returned.
            </summary>
            <returns>An array of additional base classes for initialization</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Testing.InMemoryTest.GetProperties">
            <summary>
            Hook to add additional properties for each base class' configuration. As an example, "show_sql" can
            be added to verify the behaviour of NHibernate in specific situations.
            </summary>
            <returns>A dictionary of additional or custom properties.</returns>
        </member>
        <member name="M:Castle.ActiveRecord.Testing.InMemoryTest.Configure(Castle.ActiveRecord.Framework.Config.InPlaceConfigurationSource)">
            <summary>
            Hook for modifying the configuration before initialization
            </summary>
            <param name="config"></param>
        </member>
    </members>
</doc>
